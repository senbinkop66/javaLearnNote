# 对象与类

## 1  面向对象程序设计概述

1. Java 是完全面向对象的， 必须熟悉 OOP 才能够编写 Java 程序。
2. 面向对象的程序是由对象组成的， 每个对象包含对用户公开的特定功能部分和隐藏的实现部分。
3. 从根本上说， 只要对象能够满足要求， 就不必关心其功能的具体实现过程。 在 OOP 中， 不必关心对象的具体实现， 只要能够满足用户的需求即可。
4. 对于一些规模较小的问题， 将其分解为过程的开发方式比较理想。 而面向对象更加适用于解决规模较大的问题。 

### 1.1  类

1. 类 （ class) 是构造对象的模板或蓝图。 由类构造 （construct) 对象的过程称为创建类的实例 （instance ) .
2. 封装 （ encapsulation, 有时称为数据隐藏）是与对象有关的一个重要概念。 从形式上看，封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。
3. 对象中的数据称为实例域（ instance field ), 操纵数据的过程称为方法 （ method )。 对于每个特定的类实例 （对象）都有一组特定的实例域值。 这些值的集合就是这个对象的当前状态 （ state )。无论何时， 只要向对象发送一个消息，它的状态就有可能发生改变。
4. 实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。 程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性的关键。 这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据， 其他对象就不会知道或介意所发生的变化。
5. 可以通过扩展一个类来建立另外一个新的类。事实上， 在 Java 中， 所有的类都源自于一个“ 神通广大的超类”，它就是 Object。在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。 在新类中， 只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个类的过程称为继承（inheritance)。

### 1.2  对 象

要想使用 OOP, —定要清楚对象的三个主要特性：

- **对象的行为（behavior)**—可以对对象施加哪些操作， 或可以对对象施加哪些方法？

  同一个类的所有对象实例， 由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。

- **对象的状态 （state)**—当施加那些方法时，对象如何响应？

  每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变， 但这种改变不会是自发的。 对象状态的改变必须通过调用方法实现。对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份（ identity)。

- **对象标识（identity )**—如何辨别具有相同行为与状态的不同对象？

  作为一个类的实例， 每个对象的标识永远是不同的， 状态常常也存在着差异。对象的这些关键特性在彼此之间相互影响着。

### 1.3  识 别 类

1. 识别类的简单规则是在分析问题的**过程**中寻找名词，而**方法**对应着动词。
2. 当然， 所谓“ 找名词与动词” 原则只是一种经验， 在创建类的时候， 哪些名词和动词是重要的完全取决于个人的开发经验。

### 1.4  类之间的关系

#### 1. 依赖 （“ uses-a”）
- 依赖（ dependence ), 即“uses-a” 关系， 是一种最明显的、 最常见的关系。如果一个类的方法操纵另一个类的对象， 我们就说一个类依赖于另一个类。
- 应该尽可能地将相互依赖的类减至最少。 用软件工程的术语来说， 就是让类之间的耦合度最小。

#### 2. 聚合（“ has-a”）

- 聚合（aggregation), 即“has-a” 关系， 是一种具体且易于理解的关系。 聚合关系意味着类 A 的对象包含类 B 的对象。

#### 3. 继承（“ is-a”）

- 继承（inheritance ), 即“is-a” 关系， 是一种用于表示特殊与一般关系的。一般而言， 如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。

  

## 2  使用预定义类

### 2.1  对象与对象变量

1. 要想使用对象，就必须首先构造对象， 并指定其初始状态。然后，对对象应用方法。

2. 在 Java 程序设计语言中， 使用构造器 （constructor) 构造新实例。 构造器是一种特殊的方法， 用来构造并初始化对象。

3. 构造器的名字应该与类名相同。需要在构造器前面加上 new 操作符。

4. 如果需要的话， 也可以将这个对象传递给一个方法。也可以将一个方法应用于刚刚创建的对象。

   ```java
   		new Date();
   		System.out.println(new Date());
   		String date1=new Date().toString();
   
   		Date birth=new Date();
   
   		Date deadline;
   		//初始化
   		deadline=new Date();
   		//或
   		//deadline=birth;
   
   		deadline=null;
   		String s=deadline.toString();  //ava.lang.NullPointerException
   ```

5. 在这两个例子中， 构造的对象仅使用了一次。 通常， 希望构造的对象可以多次使用， 因此，需要将对象存放在一个变量中。

6. 在对象与对象变量之间存在着一个重要的区别。定义了一个对象变量 deadline, 它 可 以 引 用 Date 类型的对象。但是， 一定要认识到： 变量deadline 不是一个对象， 实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个变量上。必须首先初始化变量 deadline, 这里有两个选择。当然，可以用新构造的对象初始化这个变量。也让这个变量引用一个已存在的对象。

7. 一定要认识到： 一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作符的返回值也是一个引用。

8. 表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 deadline 中。

9. 可以显式地将对象变量设置为 mil】， 表明这个对象变量目前没有引用任何对象。如果将一个方法应用于一个值为 null 的对象上，那么就会产生运行时错误。

10. 局部变量不会自动地初始化为 null， 而必须通过调用 new 或将它们设置为 null 进行初始化。

11. 所有的 Java 对象都存储在堆中。 当一个对象包含另一个对象变量时， 这个变量依然包含着指向另一个堆对象的指针。

### 2.2 更改器方法与访问器方法

1. 只 访 问 对 象 而 不 修 改 对 象 的 方 法 有 时 称 为 访 问 器 方 法。

2. 更改器方法，调用这个方法后，对象的状态会改变。

   

## 3  用户自定义类

### 3.1  类基本组成

1. 设计复杂应用程序所需要的各种主力类（workhorse class)。通常，这些类没有 main 方法， 却有自己的实例域和实例方法。 要想创建一个完整的程序， 应该将若干类组合在一起， 其中只有一个类有 main 方法。

2. 在一个源文件中， 只能有一个公有类，但可以有任意数目的非公有类。

3. 将 Employee 类存放在文件 Employee.java 中， 将 EmployeeTest 类存放在文件 EmployeeTest.java 中。使用通配符调用 Java编译器：javac Employee*.java  ,于是， 所有与通配符匹配的源文件都将被编译成类文件。或者键人下列命令：javac EmployeeTest.java. 使用第二种方式，并没有显式地编译 Employeejava然而， 当 Java 编译器发现 EmployeeTestjava 使用丫 Employee 类时会查找名为 Employee.class 的文件。 如果没有找到这个文件， 就会自动地搜索 Employeejava, 然后，对它进行编译。更重要的是： 如果 Employee,java 版本较已有的 Empl0yee.dass 文件版本新， Java 编译器就会自动地重新编译这个文件。

4. 类通常包括类型属于某个类类型的实例域。

5. 构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。

6. 所有的 Java 对象都是在堆中构造的， 构造器总是伴随着 new 操作符一起使用。

7. 不要在构造器中定义与实例域重名的局部变量。

   ```java
   import java.time.*;
   
   class Employee{
   	// instance fields
   	private String name;
   	private double salary;
   	private LocalDate hireDay;
   
   	//constructor
   	public Employee(String n,double s,int year,int month,int day){
   		name=n;
   		salary=s;
   		hireDay=LocalDate.of(year,month,day);
   	}
   
   	//method
   	public String getName(){
   		return name;
   	}
   	public double getSalary(){
   		return salary;
   	}
   	public LocalDate getHireDay(){
   		return hireDay;
   	}
   	public void raiseSalary(double byPercent){
   		double raise=salary*byPercent/100;
   		salary+=raise;
   	}
   
   }
   
   public class TestBase{
   	public static void main(String[] args){
   		Employee[] staff=new Employee[3];
   
   		staff[0]=new Employee("mane",20,1994,12,11);
   		staff[1]=new Employee("Alison",23,1993,10,5);
   		staff[2]=new Employee("Arnold",18,2000,4,12);
   
   		for (Employee e:staff){
   			e.raiseSalary(5);
   		}
   
   		for (Employee e:staff){
   			System.out.println("name:"+e.getName()+",salary:"+e.getSalary()+",hireDay:"+e.getHireDay());
   		}
   
   	}
   }
   ```

### 3.2  隐式参数与显式参数

1. 显式参数是明显地列在方法声明中的。隐式参数没有出现在方法声明中。在每一个方法中， 关键字 this 表示隐式参数。用this这样可以将实例域与局部变量明显地区分开来.


```java
   	public Employee(String n,double s,int year,int month,int day){
   		this.name=n;
   		this.salary=s;
   		this.hireDay=LocalDate.of(year,month,day);
   	}
```
2. 在 Java 中， 所有的方法都必须在类的内部定义， 但并不表示它们是内联方法。 是否将某个方法设置为内联方法是 Java 虚拟机的任务。 即时编译器会监视调用那些简洁、 经常被调用、 没有被重载以及可优化的方法。

### 3.3  封装

```java
//method
	public String getName(){
		return name;
	}
	public double getSalary(){
		return salary;
	}
	public LocalDate getHireDay(){
		return hireDay;
	}
	public void raiseSalary(double byPercent){
		double raise=salary*byPercent/100;
		salary+=raise;
	}
```

这些都是典型的访问器方法。由于它们只返回实例域值， 因此又称为域访问器。

在有些时候， 需要获得或设置实例域的值。因此，应该提供下面三项内容：

1. 一个私有的数据域；
2. 一个公有的域访问器方法；
3. 一个公有的域更改器方法。

这样做要比提供一个简单的公有数据域复杂些， 但是却有着下列明显的好处：

- 首先， 可以改变内部实现，除了该类的方法之外， 不会影响其他代码。
- 更改器方法可以执行错误检查， 然而直接对域进行赋值将不会进行这些处理。

```java
private Date hireDay;
public Date getHireDayO
{
	return hireDay; // Bad
}
```

LocalDate 类没有更改器方法， 与之不同， Date 类有一个更改器方法 setTime, 可以在这里设置毫秒数。Date 对象是可变的， 这一点就破坏了封装性！ 

如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone)。 对象 clone 是指存放在另一个位置上的对象副本。凭经验可知， 如果需要返回一个可变数据域的拷贝， 就应该使用 clone。

### 3.4 基于类的访问权限

方法可以访问所调用对象的私有数据。一个方法可以访问所属类的所有对象的私有数据.

### 3.5 私有方法

1. 在 Java 中，为了实现一个私有的方法， 只需将关键字 public 改为 private 即可。
2. 对于私有方法， 如果改用其他方法实现相应的操作， 则不必保留原有的方法。
3. 只要方法是私有的，类的设计者就可以确信：它不会被外部的其他类操作调用， 可以将其删去。如果方法是公有的， 就不能将其删去， 因为其他的代码很可能依赖它。

### 3.6  final 实例域

1. 可以将实例域定义为 final。 构建对象时必须初始化这样的域。也就是说， 必须确保在每一个构造器执行之后， 这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。

   ```java
   class Employee{
   	// instance fields
   	private final String company;
   	private String name;
   	private double salary;
   	private LocalDate hireDay;
   }
   ```

2. final 修饰符大都应用于基本 （primitive) 类型域， 或不可变 （immutable) 类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类。 例如，String 类就是一个不可变的类 )。

3. 对于可变的类， 使用 final 修饰符可能会对读者造成混乱。

## 4  静态域与静态方法

