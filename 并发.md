# 并发

1. 并发执行的进程数目并不是由 CPU 数目制约的。操作系统将 CPU 的时间片分配给每一个进程， 给人并行处理的感觉。
2. 多线程程序在较低的层次上扩展了多任务的概念： 一个程序同时执行多个任务。通常，每一个任务称为一个线程（thread), 它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序（multithreaded)。
3. 多进程与多线程有哪些区别呢？ 本质的区别在于每个进程拥有自己的一整套变量， 而线程则共享数据。 
   - 共享变量使线程之间的通信比进程之间的通信更有效、 更容易。
   - 此外， 在有些操作系统中， 与进程相比较， 线程更“ 轻量级”， 创建、 撤销一个线程比启动新进程的开销要小得多。

## 1  什么是线程

1. 调用 Threadsleep 不会创建一个新线程，sleep 是 Thread 类的静态方法，用于暂停当前线程的活动。
2. sleep 方法可以抛出一个 IntermptedException 异常。

```java
import java.util.*;
import java.time.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.geom.*;

class Ball{
	private static final int XSIZE=15;
	private static final int YSIZE=15;
	private double x=0;
	private double y=0;
	private double dx=1;
	private double dy=1;

	public void move(Rectangle2D bounds){
		x+=dx;
		y+=dy;
		if (x<bounds.getMinX()) {
			x=bounds.getMinX();
			dx=-dx;
		}
		if (x+XSIZE>=bounds.getMaxX()) {
			x=bounds.getMaxX()-XSIZE;
			dx=-dx;
		}
		if (y<bounds.getMinY()) {
			y=bounds.getMinY();
			dy=-dy;
		}
		if (y+YSIZE>=bounds.getMaxY()) {
			y=bounds.getMaxY()-YSIZE;
			dy=-dy;
		}
	}
	public Ellipse2D getShape(){
		return new Ellipse2D.Double(x,y,XSIZE,YSIZE);
	}
}

class BallComponent extends JPanel{
	private static final int DEFAULT_WIDTH=600;
	private static final int DEFAULT_HEIGHT=600;

	private java.util.List<Ball> balls=new ArrayList<>();

	public void add(Ball b){
		balls.add(b);
	}

	public void paintComponent(Graphics g){
		super.paintComponent(g);
		Graphics2D g2=(Graphics2D) g;
		g2.setPaint(Color.BLUE);
		for (Ball b:balls){
			g2.fill(b.getShape());
		}
	}
	public Dimension getPreferredSize(){
		return new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT);
	}
}

class BounceFrame extends JFrame{
	private BallComponent comp;
	public static final int STEPS=1000;
	public static final int DELAY=3;

	public BounceFrame(){
		comp=new BallComponent();
		add(comp,BorderLayout.CENTER);
		JPanel buttonPanel=new JPanel();
		addButton(buttonPanel,"Start",event->addBall());
		addButton(buttonPanel,"Close",event->System.exit(0));
		add(buttonPanel,BorderLayout.SOUTH);
		pack();
	}

	public void addButton(Container c,String title,ActionListener listener){
		JButton button=new JButton(title);
		c.add(button);
		button.addActionListener(listener);
	}

	public void addBall(){
		try{
			Ball ball=new Ball();
			comp.add(ball);
			for (int i=1; i<=STEPS; i++) {
				ball.move(comp.getBounds());
				comp.paint(comp.getGraphics());
				Thread.sleep(DELAY);
			}
		}catch(InterruptedException e){
			e.printStackTrace();
		}
	}
}

public class TestBase9{
	public static void main(String[] args) {
		EventQueue.invokeLater(()->{
			JFrame frame=new BounceFrame();
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setTitle("弹球");  //设置框架标题
			frame.setLocation(300,300);
			frame.setVisible(true);  //使其可见性
		});
	}
}
```

### 1.1  使用线程给其他任务提供机会

1. 可以将移动球的代码放置在一个独立的线程中， 运行这段代码可以提高弹跳球的响应能力。实际上，可以发起多个球， 每个球都在自己的线程中运行。另外，AWT 的事件分派线程( event dispatch thread) 将一直地并行运行， 以处理用户界面的事件。由于每个线程都有机会得以运行，所以在球弹跳期间， 当用户点击 Close 按钮时， 事件调度线程将有机会关注到这个事件， 并处理“ 关闭” 这一动作。

```java
public void addBall(){
		Ball ball=new Ball();
		comp.add(ball);
		Runnable r=()->{
			try{
				for (int i=1; i<=STEPS; i++) {
					ball.move(comp.getBounds());
					comp.repaint();
					Thread.sleep(DELAY);
				}
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		};
		Thread t=new Thread(r);
		t.start();
	}
```
2. 在一个单独的线程中执行一个任务的简单过程：

   - 将任务代码移到实现了 Runnable 接口的类的 run 方法中。这个接口非常简单， 只有一个方法：

     public interface Runnable
     {
     	void run()；
     }

     由于 Runnable 是一个函数式接口，可以用 lambda 表达式建立一个实例：Runnable r = () -> { task code };

   - 由 Runnable 创建一个 Thread 对象： Thread t = new Thread(r);

   - 启动线程：t.start()；

3. 也可以通过构建一个 Thread 类的子类定义一个线程，

   ```
   class MyThread extends Thread
   {
       public void run()
       {
       task code
       }
   }
   ```

   然后， 构造一个子类的对象， 并调用 start 方法。 不过， 这种方法已不再推荐。 应该将要并行运行的任务与运行机制解耦合。如果有很多任务， 要为每个任务创建一个独立的线程所付出的代价太大了。 可以使用线程池来解决这个问题，

4. 不要调用 Thread 类或 Runnable 对象的 run 方法。 直接调用 run 方法， 只会执行同一个线程中的任务， 而不会启动新线程。 应该调用 Thread.start 方法。这个方法将创建一个执行 run 方法的新线程。

```java
java.lang.Thread
	Thread(Runnable target )  //构造一个新线程， 用于调用给定目标的 run() 方法。
	void start( )  //启动这个线程， 将引发调用 run() 方法。这个方法将立即返回， 并且新线程将并发运行。
	void run( )  //调用关联 Runnable 的 run 方法。
    void interrupt()  /*向线程发送中断请求。线程的中断状态将被设置为 true。如果目前该线程被一个 sleep调用阻塞，那么， InterruptedException 异常被抛出。*/
	static boolean interrupted()  /*测试当前线程（即正在执行这一命令的线程）是否被中断。注意，这是一个静态方法。	这一调用会产生副作用—它将当前线程的中断状态重置为 false。*/
	boolean isInterrupted()  //测试线程是否被终止。不像静态的中断方法，这一调用不改变线程的中断状态。
	static Thread currentThread()  //返回代表当前执行线程的 Thread 对象。
    void join( )  //等待终止指定的线程。
	void join(long mi11is)  //等待指定的线程死亡或者经过指定的毫秒数。
	Thread.State getState()  //得到这一线程的状态；NEW、RUNNABLE、BLOCKED、 WAITING、TIMED_WAITING或 TERMINATED 之一。
	void stop()  //停止该线程。这一方法已过时。
    void suspend()  //暂停这一线程的执行
	void resume()  //恢复线程。这一方法仅仅在调用 suspendO 之后调用。这一方法已过时。
    void setPriority(int newPriority)  //设置线程的优先级。
	static int MIN_PRIORITY  //线程的最小优先级。最小优先级的值为 1。
	static int N0RM_PRI0RITY  //线程的默认优先级。默认优先级为 5。
	static int MAX_PRIORITY  //线程的最高优先级。最高优先级的值为 10。
	static void yield( )  /*导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高
	的优先级，那么这些线程接下来会被调度。注意，这是一个静态方法。*/
    void setDaemon( boolean isDaemon )  //标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。

java.lang.Runnable
	void run( )  //必须覆盖这个方法， 并在这个方法中提供所要执行的任务指令。
```

## 2  中 断 线 程

1. 当线程的 run 方法执行方法体中最后一条语句后， 并经由执行 return 语句返冋时， 或者出现了在方法中没有捕获的异常时， 线程将终止。 

2. 没有可以强制线程终止的方法。然而， interrupt 方法可以用来请求终止线程。

3. 当对一个线程调用 interrupt 方法时，线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该不时地检査这个标志， 以判断线程是否被中断。

   要想弄清中断状态是否被置位， 首先调用静态的 Thread.currentThread 方法获得当前线程， 然后调用 islnterrupted 方法：

   ```java
   while (!Thread.currentThread().islnterrupted() && more work to do)
   {
   	do more work
   }
   ```

   但是， 如果线程被阻塞， 就无法检测中断状态。 这是产生 InterruptedExceptioii 异常的地方。

4. 当在一个被阻塞的线程 （调用 sleep 或 wait) 上调用 interrupt 方法时， 阻塞调用将会被Interrupted Exception 异常中断。（存在不能被中断的阻塞 I/O 调用， 应该考虑选择可中断的调用。)

5. 没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后， 继续执行， 而不理会中断。

6. 更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的 run 方法具有如下形式：

   ```java
   Runnable r = () -> {
   	try{
   		...;
   		while (!Thread.currentThread().islnterrupted0 && more work todo){
   			do more work
   		}
   	}catch(InterruptedException e){
   		// thread was interrupted during sleep or wait
   	}finally{
   		cleanup,if required
   	}
   	// exiting the run method terminates the thread
   };
   ```

   如果在每次工作迭代之后都调用 sleep 方法（或者其他的可中断方法 )， islnterrupted 检测 既没有必要也没有用处。 如果在中断状态被置位时调用 sleep 方法， 它不会休眠。 相反，它 将清除这一状态（!）并拋出 IntemiptedException。因此， 如果你的循环调用 sleep， 不会检 测中断状态。相反，要如下所示捕获 InterruptedException 异常：

   ```java
   Runnable r = () -> {
   	try{
   		...;
   		while (!Thread.currentThread().islnterrupted0 && more work todo){
   			do more work
   			Thread.sleep(delay);
   		}
   	}catch(InterruptedException e){
   		// thread was interrupted during sleep
   	}finally{
   		cleanup,if required
   	}
   	// exiting the run method terminates the thread
   };
   ```

7. Interrupted 方法是一个静态方法， 它检测当前的线程是否被中断。 而且， 调用 interrupted 方法会清除该线程的中断状态。 另一方面， islnterrupted 方法是一个实例方法， 可用来检验是否有线程被中断。调用这个方法不会改变中断状态。

8. 在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。

   ```java
   void mySubTask(){
   	...
   	try { sleep(delay); }
   	catch (InterruptedException e) { Thread.currentThread().interrupt(); }
   	...
   }
   ```

9. 或者， 更好的选择是， 用 throws InterruptedException 标记你的方法， 不采用 try 语句块捕获异常。于是， 调用者（或者， 最终的 run 方法）可以捕获这一异常。

   ```java
   void mySubTask() throws InterruptedException{
   	...
   	sleep(delay);
   	...
   }
   ```

   

## 3  线程状态

线程可以有如下 6 种状态：要确定一个线程的当前状态， 可调用 getState 方法。

- New (新创建）
- Runnable (可运行）
- Blocked ( 被阻塞）
- Waiting (等待）
- Timed waiting (计时等待）
- Terminated (被终止）

### 3.1  新创建线程

1. 当用 new 操作符创建一个新线程时， 如 newThread(r)， 该线程还没有开始运行。这意味着它的状态是 new。当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

### 3.2  可运行线程

1. 一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线桿可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。（Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态。）
2. 一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。
3. 线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。 当时间片用完， 操作系统剥夺该线程的运行权， 并给另一个线程运行机会。当选择下一个线程时， 操作系统考虑线程的优先级。
4. 现在所有的桌面以及服务器操作系统都使用抢占式调度。但是， 像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 yield 方法、 或者被阻塞或等待时，线程才失去控制权。
5. 在具有多个处理器的机器上， 每一个处理器运行一个线程， 可以有多个线程并行运行。当然， 如果线程的数目多于处理器的数目， 调度器依然采用时间片机制。
6. 在任何给定时刻，二个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行)。

### 3.3  被阻塞线程和等待线程

1. 当线程处于被阻塞或等待状态时， 它暂时不活动。 它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。 细节取决于它是怎样达到非活动状态的。
   - 当一个线程试图获取一个内部的对象锁（而不是 javiutiUoncurrent 库中的锁)， 而该锁被其他线程持有， 则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
   - 当线程等待另一个线程通知调度器一个条件时， 它自己进入等待状态。在调用 Object.wait 方法或 Thread.join 方法， 或者是等待 java,util.concurrent 库中的 Lock 或 Condition 时， 就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。
   - 有几个方法有一个超时参数。调用它们导致线程进人计时等待（ timed waiting) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep 和 Object.wait、 Thread.join、 Lock,tryLock 以及 Condition.await 的计时版。

### 3.4  被终止的线程

1. 线程因如下两个原因之一而被终止：
   - 因为 run 方法正常退出而自然死亡。
   - 因为一个没有捕获的异常终止了 nm 方法而意外死亡。

线程状态

![线程状态](E:\pogject\javalearn\学习笔记\img\线程状态.png)

当一个线程被阻塞或等待时（或终止时)， 另一个线程被调度为运行状态。当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁)，调度器检查它是否具有比当前运行线程更高的优先级。 如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。

## 4  线 程 属 性

### 4.1  线程优先级

1. 在 Java 程序设计语言中， 每一个线程有一个优先级。 默认情况下， 一+线程继承它的父线程的优先级。 
2. 可以用 setPriority 方法提高或降低任何一个线程的优先级。可以将优先级设 置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的 任何值。NORM_PRIORITY 被定义为 5。
3. 每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。 当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多，也许更少。
4. 不要将程序构建为功能的正确性依赖于优先级。如果有几个高优先级的线程没有进入非活动状态， 低优先级的线程可能永远也不能执行。每当调度器决定运
   行一个新线程时， 首先会在具有高优先级的线程中进行选择， 尽管这样会使低优先级的线程完全饿死。

### 4.2  守护线程

1. 可以通过调用 **t.setDaemon(true)** ;将线程转换为守护线程（daemon thread)。
2. 守护线程的唯一用途是为其他线程提供服务。计时线程就是一个例子，它定时地发送“ 计时器嘀嗒” 信号给其他线程或清空过时的高速缓存项的线程。当只剩下守护线程时， 虚拟机就退出了， 由于如果只剩下守护线程， 就没必要继续运行程序了。
3. 守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

### 4.3  未捕获异常处理器

1. 线程的 run 方法不能抛出任何受查异常， 但是，非受査异常会导致线程终止。在这种情况下，线程就死亡了。
2. 不需要任何 catch 子句来处理可以被传播的异常。 相反， 就在线程死亡之前， 异常被传递到一个用于未捕获异常的处理器。该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类。这个接口只有—个方法。 **void uncaughtException(Thread t, Throwable e)**
3. 可以用 setUncaughtExceptionHandler 方法为任何线程安装一个处理器。也可以用 Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有线程安装一个默认的处理器。 替换处理器可以使用日志 API 发送未捕获异常的报告到日志文件。
4. 如果不安装默认的处理器， 默认的处理器为空。 但是， 如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。
5. 线程组是一个可以统一管理的线程集合。默认情况下， 创建的所有线程属于相同的线程组， 但是， 也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。
6. ThreadGroup 类实现 Thread.UncaughtExceptionHandler 接口。 它的 uncaughtException 方法做如下操作：
   - 如果该线程组有父线程组， 那么父线程组的 uncaughtException 方法被调用。
   - 否则， 如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器， 则调用该处理器。
   - 否则， 如果 Throwable 是 ThreadDeath 的一个实例， 什么都不做。
   - 否则， 线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。（但是， 如果 e 是一个 ThreadDeath对象， 栈轨迹是被禁用的。)

```java
java.lang.Thread
	static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) 
	static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()
	//设置或获取未捕获异常的默认处理器。
	void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)
	Thread.UncaughtExceptionHandler getUncaughtExceptionHandler( )
	//设置或获取未捕获异常的处理器。 如果没有安装处理器， 则将线程组对象作为处理器。
java.lang.Thread.UncaughtExceptionHandler 
	void UncaughtException(Thread t, Throwable e)  //当一个线程因未捕获异常而终止， 按规定要将客户报告记录到日志中。

java.lang.ThreadGroup
	void UncaughtException(Thread t, Throwable e)  /**/
```



##  5  同 步

### 5.1  竞争条件的产生

1. 在大多数实际的多线程应用中， 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象， 并且每一个线程都调用了一个修改该对象状态的方法，将会发 生什么呢？ 可以想象， 线程彼此踩了对方的脚。 根据各线程访问数据的次序， 可能会产生i化 误的对象。这样一个情况通常称为竞争条件（race condition)。

   非同步存取银行账户

   ```java
   import java.util.*;
   
   class Bank{
   	private final double[] accounts;
   
   	public Bank(int n,double initialBalance){
   		accounts=new double[n];
   		Arrays.fill(accounts,initialBalance);
   	}
   
   	public void transfer(int from,int to,double amount){
   		if (accounts[from]<amount) return;
   		System.out.print(Thread.currentThread());
   		accounts[from]-=amount;
   		System.out.printf(" %10.2f from %d to %d",amount,from,to);
   		accounts[to]+=amount;
   		System.out.printf(" 总额: %10.2f%n",getTotalBalance());
   	}
   	public double getTotalBalance(){
   		double sum=0;
   		for (double a:accounts){
   			sum+=a;
   		}
   		return sum;
   	}
   	public int size(){
   		return accounts.length;
   	}
   }
   
   public class TestSynchBase1{
   	public static final int NACCOUNTS=100;
   	public static final double INITIAL_BALANCE=1000;
   	public static final double MAX_AMOUNT=1000;
   	public static final int DELAY=10;
   
   	public static void main(String[] args) {
   		Bank bank=new Bank(NACCOUNTS,INITIAL_BALANCE);
   		for (int i=0; i<NACCOUNTS; i++) {
   			int fromAccount=i;
   			Runnable r=()->{
   				try{
   					while(true){
   						int toAccount=(int) (bank.size()*Math.random());
   						double amount=MAX_AMOUNT*Math.random();
   						bank.transfer(fromAccount,toAccount,amount);
   						Thread.sleep((int)(DELAY*Math.random()));
   					}
   				}catch (InterruptedException e){
   					e.printStackTrace();
   				}
   			};
   			Thread t=new Thread(r);
   			t.start();
   		}
   	}
   }
   ```

   

### 5.2  竞争条件详解

1. 真正的问题是 transfer 方法的执行过程中可能会被中断。 如果能够确保线程在失去控制之前方法运行完成， 那么银行账户对象的状态永远不会出现讹误。

### 5.3  锁对象

1. 有两种机制防止代码块受并发访问的干扰。Java 语言提供一个 synchronized 关键字达到这一目的， 并且 Java SE 5.0 引入了 ReentrantLock 类。synchronized 关键字自动提供一个锁以及相关的“ 条件”， 对于大多数需要显式锁的情况， 这是很便利的。

2. 用 ReentrantLock 保护代码块的基本结构如下：

   ```java
   myLock.lock(); // a ReentrantLock object
   try{
   	critical section
   }finally{
   	myLock.unlock()；// make sure the lock is unlocked even if an exception is thrown
   }
   ```

   这一结构确保任何时刻只有一个线程进人临界区。一旦一个线程封锁了锁对象， 其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞， 直到第一个线程释放锁对象。

3. 把解锁操作括在 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。 否则， 其他线程将永远阻塞。

4. 如果使用锁， 就不能使用带资源的 try 语句。首先， 解锁方法名不是 close。不过，即使将它重命名， 带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁， 你可能想使用多个线程共享的那个变量（而不是新变量）。

5. 锁是可重入的， 因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（ hold count) 来跟踪对 lock 方法的嵌套调用。线程在每一次调用 lock 都要调用 unlock 来释放锁。由于这一特性， 被一个锁保护的代码可以调用另一个使用相同的锁的方法。

6. 通常， 可能想要保护需若干个操作来更新或检查共享对象的代码块。要确保这些操作完成后， 另一个线程才能使用相同对象。

7. 要留心临界区中的代码， 不要因为异常的抛出而跳出临界区。 如果在临界区代码结束之前抛出了异常， finally 子句将释放锁，但会使对象可能处于一种受损状态。

   **加锁同步存取银行账户**

   ```java
   import java.util.concurrent.locks.Lock;
   import java.util.concurrent.locks.ReentrantLock;
   	public void transfer(int from,int to,double amount){
   		if (accounts[from]<amount) return;
   		bankLock.lock();
   		try{
   			System.out.print(Thread.currentThread());
   			accounts[from]-=amount;
   			System.out.printf(" %10.2f from %d to %d",amount,from,to);
   			accounts[to]+=amount;
   			System.out.printf(" 总额: %10.2f%n",getTotalBalance());
   		}finally{
   			bankLock.unlock();
   		}
   	}	
   import java.util.concurrent.locks.Lock;
   	void lock( )  //获取这个锁；如果锁同时被另一个线程拥有则发生阻塞。
   	void unlock( )  //释放这个锁。
   import java.util.concurrent.locks.ReentrantLock;
   	ReentrantLock( )  //构建一个可以被用来保护临界区的可重入锁。
   	ReentrantLock(boo1ean fair )  /*构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。 但是，这一公平
   	的保证将大大降低性能。 所以， 默认情况下， 锁没有被强制为公平的。*/
   
   ```

8. 即使使用公平锁， 也无法确保线程调度器是公平的。 如果线程调度器选择忽略一个线程， 而该线程为了这个锁已经等待了很长时间， 那么就没有机会公平地处理这个锁了。

### 5.4  条件对象

1. 通常， 线程进人临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。（由于历史的原因， 条件对象经常被称为条件变量（conditionalvariable)。）

2. 一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。

3. 等待获得锁的线程和调用 await 方法的线程存在本质上的不同。一旦一个线程调用 await方法， 它进人该条件的等待集。 当锁可用时，该线程不能马上解除阻塞。 相反，它处于阻塞状态，直到另一个线程调用同一条件上的 signalAll 方法时为止。

4. 当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时， 它们将试图重新进人该对象。一旦锁成为可用的，它们中的某个将从 await 调用返回， 获得该锁并从被阻塞的地方继续执行。

5. 此时， 线程应该再次测试该条件。 由于无法确保该条件被满足—signalAll 方法仅仅是通知正在等待的线程：此时有可能已经满足条件， 值得再次去检测该条件。

6. 通常， 对 await 的调用应该在如下形式的循环体中

   ```
   while (!(ok to proceed) )
   	condition.await();
   ```

7. 当一个线程调用 await 时， 它 没有办法重新激活自身。它寄希望于其他线程。 如果没有其他线程来重新激活等待的线程， 它就永远不再运行了。这将导致令人不快的死锁（deadlock) 现象。 如果所有其他线程被阻 塞， 最后一个活动线程在解除其他线程的阻塞状态之前就调用 await 方法， 那么它也被阻塞。 没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。

8. 应该何时调用 signalAll 呢？ 经验上讲， 在对象的状态有利于等待线程的方向改变时调用signalAll。例如， 当一个账户余额发生改变时， 等待的线程会应该有机会检查余额。在例子中， 当完成了转账时， 调用 signalAll 方法。

9. 注意调用 signalAll 不会立即激活一个等待线程。它仅仅解除等待线程的阻塞， 以便这些线程可以在当前线程退出同步方法之后， 通过竞争实现对对象的访问。

10. 另一个方法 signal, 则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。 如果随机选择的线程发现自己仍然不能运行， 那么它再次被阻塞。如果没有其他线程再次调用 signal, 那么系统就死锁了。

11. 当一个线程拥有某个条件的锁时， 它仅仅可以在该条件上调用 await、signalAll 或signal 方法。

```java
class Bank{
	private final double[] accounts;
	private Lock bankLock;
	private Condition sufficientFunds;

	public Bank(int n,double initialBalance){
		accounts=new double[n];
		Arrays.fill(accounts,initialBalance);
		bankLock=new ReentrantLock();
		sufficientFunds=bankLock.newCondition();
	}

	public void transfer(int from,int to,double amount) throws InterruptedException{
		bankLock.lock();
		try{
			while(accounts[from]<amount){
				sufficientFunds.await();
			}
			System.out.print(Thread.currentThread());
			accounts[from]-=amount;
			System.out.printf(" %10.2f from %d to %d",amount,from,to);
			accounts[to]+=amount;
			System.out.printf(" 总额: %10.2f%n",getTotalBalance());
			sufficientFunds.signalAll();
		}finally{
			bankLock.unlock();
		}
	}
	public double getTotalBalance(){
		bankLock.lock();
		try{
			double sum=0;
			for (double a:accounts){
				sum+=a;
			}
			return sum;
		}finally{
			bankLock.unlock();
		}
	}
	public int size(){
		return accounts.length;
	}
}

java.util.concurrent.locks.Lock
	Condition newCondition( )  //返回一个与该锁相关的条件对象。
java.util.concurrent.locks.Condition
	void await( )  //将该线程放到条件的等待集中。
	void signalA11( )  //解除该条件的等待集中的所有线程的阻塞状态。
	void signal ( )  //从该条件的等待集中随机地选择一个线程， 解除其阻塞状态。
```

### 5.5  synchronized 关键字

1. 有关锁和条件的关键之处：

   - 锁用来保护代码片段， 任何时刻只能有一个线程执行被保护的代码。
   - 锁可以管理试图进入被保护代码段的线程。
   - 锁可以拥有一个或多个相关的条件对象。
   - 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

2. Lock 和 Condition 接口为程序设计人员提供了高度的锁定控制。然而， 大多数情况下，并不需要那样的控制，并且可以使用一种嵌人到 Java 语言内部的机制。

   ```java
   public synchronized void method(){
   	method body
   }
   //等价于
   public void method(){
   	this.intrinsicLock.lock();
   	try{
   		method body
   	}finally{
   		this.intrinsicLock.unlock();
   	}
   }
   ```

   

3. 从 1.0 版开始，Java中的每一个对象都有一个内部锁。 如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法， 线程必须获得内部的对象锁。例如， 可以简单地声明 Bank 类的 transfer 方法为 synchronized, 而不是使用一个显式的锁。

4. 内部对象锁只有一个相关条件。wait 方法添加一个线程到等待集中，notifyAU /notify 方法解除等待线程的阻塞状态。换句话说，调用 wait 或 notityAll 等价于

   **intrinsicCondition.await();**
   **intrinsicCondition.signalAIl();**

5. wait、notifyAll 以及 notify 方法是 Object 类的 final 方法。Condition 方法必须被命名为 await、signalAll 和 signal 以便它们不会与那些方法发生冲突。

```java
	public synchronized void transfer(int from,int to,double amount) throws InterruptedException{
			while(accounts[from]<amount){
				wait();
			}
			System.out.print(Thread.currentThread());
			accounts[from]-=amount;
			System.out.printf(" %10.2f from %d to %d",amount,from,to);
			accounts[to]+=amount;
			System.out.printf(" 总额: %10.2f%n",getTotalBalance());
			notifyAll();
	}
	public synchronized double getTotalBalance(){
		double sum=0;
		for (double a:accounts){
			sum+=a;
		}
		return sum;
	}

java.lang.Object 
	void notifyAll()  /*解除那些在该对象上调用 wait 方法的线程的阻塞状态。该方法只能在同步方法或同步块内
	部调用。 如果当前线程不是对象锁的持有者，该方法拋出一个 IllegalMonitorStateException异常。*/
	void notify( )  /*随机选择一个在该对象上调用 wait 方法的线程， 解除其阻塞状态。该方法只能在一个同步方法或同步块中调用。 */
	void wait( )  //导致线程进人等待状态直到它被通知。该方法只能在一个同步方法中调用。
	void wait(long mi11is)
	void wait(long millis, int nanos )  //导致线程进入等待状态直到它被通知或者经过指定的时间。
```

使用 synchronized 关键字来编写代码要简洁得多。 当然， 要理解这一代码， 必须了解每一个对象有一个内部锁， 并且该锁有一个内部条件。由锁来管理那些试图进入synchronized 方法的线程， 由条件来管理那些调用 wait 的线程。

6. 将静态方法声明为 synchronized 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如， 如果 Bank 类有一个静态同步的方法，那么当该方法被调用时，Bank.class对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。
7. 内部锁和条件存在一些局限。包括：
   - 不能中断一个正在试图获得锁的线程。
   - 试图获得锁时不能设定超时。
   - 每个锁仅有单一的条件， 可能是不够的。
8. 在代码中应该使用哪一种？ Lock 和 Condition 对象还是同步方法？下面是一些建议：
   - 最好既不使用 Lock/Condition 也不使用 synchronized 关键字。 在许多情况下你可以使用 java.util.concurrent 包中的一种机制，它会为你处理所有的加锁。
   - 如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。
   - 如果特别需要 Lock/Condition 结构提供的独有特性时，才使用 Lock/Condition。

### 5.6  同步阻塞

1. 每一个 Java 对象有一个锁。线程可以通过调用同步方法获得锁。还有另一种机制可以获得锁，通过进入一个同步阻塞。当线程进入如下形式的阻塞：

2. 当线程进入如下形式的阻塞：

   ```
   synchronized (obj) // this is the syntax for a synchronized block
   {
   	critical section
   }
   ```

   于是它获得 obj 的锁。在此， lock 对象被创建仅仅是用来使用每个 Java 对象持有的锁。

3. 有时程序员使用一个对象的锁来实现额外的原子操作， 实际上称为客户端锁定（client-side locking) 。客户端锁定是非常脆弱的，通常不推荐使用。

### 5.7  监视器概念

1. 锁和条件是线程同步的强大工具，但是，严格地讲， 它们不是面向对象的。

2. 在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性。最成功的解决方案之一是监视器 （monitor), 用 Java 的术语来讲， 监视器具有如下特性：

   - 监视器是只包含私有域的类。

   - 每个监视器类的对象有一个相关的锁。

   - 用该锁对所有的方法进行加锁。

     换句话说， 如果客户端调用 obj.method(), 那 么 obj对象的锁是在方法调用开始时自动获得， 并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时， 没有其他线程能访问该域。

   - 该锁可以有任意多个相关条件。

3.  Java 中的每一个对象有一个内部的锁和内部的条件。 如果一个方法用 synchronized 关键字声明，那么，它表现的就像是一个监视器方法。通过调用 wait/notifyAU/notify 来访问条件变量。

4. 然而， 在下述的 3 个方面 Java 对象不同于监视器， 从而使得线程的安全性下降：

   - 域不要求必须是 private。
   - 方法不要求必须是 synchronized。
   - 内部锁对客户是可用的。

### 5.8  Volatile 域

1. 使用现代的处理器与编译器， 出错的可能性很大。

   - 多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。
   - 编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义， 但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变！

   如果你使用锁来保护可以被多个线程访问的代码， 那么可以不考虑这种问题。 编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应， 并且不能不正当地重新排序指令。

2. volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。

   例如， 假定一个对象有一个布尔标记 done, 它的值被一个线程设置却被另一个线程査询， 如同我们讨论过的那样，你可以使用锁：

   ```java
   private boolean done;
   public synchronized boolean isDone() { return done; }
   public synchronized void setDone() { done = true; }
   //或许使用内部锁不是个好主意。如果另一个线程已经对该对象加锁， isDone 和 setDone方法可能阻塞。
   ```

   在这种情况下，将域声明为 volatile 是合理的：

   ```java
   private volatile boolean done;
   public boolean isDone() { return done; }
   public void setDone() { done = true; }
   ```

3. Volatile 变量不能提供原子性。

### 5.9  final 变置

1.  除非使用锁或 volatile 修饰符， 否则无法从多个线程安全地读取一个域。

2. 还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时。

   **final Map<String, Double〉accounts = new HashKap<>()；**

   其他线程会在构造函数完成构造之后才看到这个 accounts 变量。

3. 如果不使用 final，就不能保证其他线程看到的是 accounts 更新后的值，它们可能都只是看到 null, 而不是新构造的 HashMap。

4. 当然，对这个映射表的操作并不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步。

### 5.10  原子性

1. 假设对共享变量除了赋值之外并不完成其他操作， 那么可以将这些共享变量声明为volatile。

2. java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性。 例如， Atomiclnteger 类提供了方法 incrementAndGet 和decrementAndGet, 它们分别以原子方式将一个整数自增或自减。

   例如，可以安全地生成一个数值序列，如下所示：

   ```java
   public static AtomicLong nextNumber = new AtomicLong() ;
   // In some thread...
   long id = nextNumber.incrementAndGet();
   ```

   incrementAndGet 方法以原子方式将 AtomicLong 自增， 并返回自增后的值。也就是说，获得值、 增 1 并设置然后生成新值的操作不会中断。可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。

3. 有很多方法可以以原子方式设置和增减值， 不过， 如果希望完成更复杂的更新，就必须使用 compareAndSet 方法。 

   例如， 假设希望跟踪不同线程观察的最大值。下面的代码是不可行的：

   ```java
   public static AtonicLong largest = new AtomicLong()；
   // In some thread...
   largest.set(Math,max(largest.get(), observed)); // Error race condition!
   ```

   这个更新不是原子的。

   实际上，应当在一个循环中计算新值和使用 compareAndSet:

   ```java
   do {
   	oldValue = largest.get();
   	newValue = Math.max(oldValue, observed);
   } while (!largest.compareAndSet(oldValue, newValue));	
   ```

   如果另一个线程也在更新 largest，就可能阻止这个线程更新。这样一来，compareAndSet会返回 false, 而不会设置新值。在这种情况下， 循环会更次尝试，读取更新后的值，并尝试修改。 最终， 它会成功地用新值替换原来的值。这听上去有些麻烦， 不过 compareAndSet 方法会映射到一个处理器操作， 比使用锁速度更快。

4. 在 Java SE 8 中，不再需要编写这样的循环样板代码。实际上， 可以提供一个 lambda 表达式更新变量，它会为你完成更新。

   ```java
   largest.updateAndGet(x -> Math.max(x, observed)) ;
   //或
   largest.accumulateAndCet(observed, Math::max);
   ```

5. accumulateAndGet 方法利用一个二元操作符来合并原子值和所提供的参数。还有 getAndUpdate 和 getAndAccumulate 方法可以返回原值。

6. 如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。

   - LongAdder 包括多个变量（加数)，其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。

   - 如果认为可能存在大量竞争， 只需要使用 LongAdder 而不是 AtomicLong。方法名稍有区别。调用 increment 让计数器自增，或者调用 add 来增加一个量， 或者调用 sum 来获取总和。

   - 当然， increment 方法不会返回原值。这样做会消除将求和分解到多个加数所带来的性能提升。

   - LongAccumulator 将这种思想推广到任意的累加操作。 在构造器中， 可以提供这个操作以及它的零元素。要加人新的值， 可以调用 accumulate。调用 get 来获得当前值。

     ```java
     LongAccumulator adder = new LongAccumulator(Long::sum, 0);
     // In some thread...
     adder.accumulate(value);
     ```

     在内部，这个累加器包含变量 a1, a2，…，an。每个变量初始化为零元素（这个例子中零元素为 0 )。

   - 调用 accumulate 并提供值 v 时，其中一 个变量会以原子方式更新为ai= ai op v, 这里 op是中缀形式的累加操作。get 的结果是 a1 opa2  op . . .op an.

   - 如果选择一个不同的操作，可以计算最小值或最大值。一般地， 这个操作必须满足结合律和交换律。这说明， 最终结果必须独立于所结合的中间值的顺序。

   - 另外 DoubleAdder 和 DoubleAccumulator 也采用同样的方式， 只不过处理的是 double 值。

### 5.11  死锁

1. 锁和条件不能解决多线程中的所有问题。
2. 有可能会因为每一个线程要等待更多的钱款存人而导致所有线程都被阻塞。这样的状态称为死锁（deadlock)。
3. 当程序挂起时， 键入 CTRL+\, 将得到一个所有线程的列表。每一个线程有一个栈踪迹， 告诉你线程被阻塞的位置。
   - 导致死锁的另一种途径是让第i个线程负责向第i个账户存钱，而不是从第i个账户取钱。这样一来，有可能将所有的线程都集中到一个账户上，每一个线程都试图从这个账户中取出大于该账户余额的钱。
   - 还有一种很容易导致死锁的情况： 在 SynchBankTest 程序中， 将 signalAll 方法转换为 signal , 会发现该程序最终会挂起（将 NACCOUNTS 设为 10 可以更快地看到结果）。
   - signalAll 通知所有等待增加资金的线程， 与此不同的是 signal方法仅仅对一个线程解锁。 如果该线程不能继续运行，所有的线程可能都被阻塞。 
4.  Java 编程语言中没有任何东西可以避免或打破这种死锁现象。必须仔细设计程序， 以确保不会出现死锁。

### 5.12  线程局部变量

1. 有时可能要避免共享变量， 使用ThreadLocal 辅助类为各个线程提供各自的实例。SimpleDateFormat 类不是线程安全的。要为每个线程构造一个实例，可以使用以下代码：

   ```java
   public static final ThreadLocal<SimpleDateFormat> dateFormat =
   	ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
   //要访问具体的格式化方法， 可以调用：
   String dateStamp = dateFormat.get().format(new Date());
   ```

2. 在一个给定线程中首次调用 get 时， 会调用 initialValue 方法。在此之后， get 方法会返回属于当前线程的那个实例。

3. 在多个线程中生成随机数也存在类似的问题。java..util.Rand0m 类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器， 这会很低效。

4. 可以使用 ThreadLocal 辅助类为各个线程提供一个单独的生成器， 不过 Java SE 7 还另外提供了一个便利类。只需要做以下调用：

   ```java
   int random = ThreadLocalRandom.current().nextlnt(upperBound):
   ```

   ThreadLocalRandom.current() 调用会返回特定于当前线程的 Random 类实例。

   ```java
   java.lang.ThreadLocal<T>
   	T get( )  //得到这个线程的当前值。如果是首次调用 get, 会调用 initialize 来得到这个值。
   	protected initialize( )  //应覆盖这个方法来提供一个初始值。默认情况下，这个方法返回 mill。
   	void set(T t)  //为这个线程设置一个新值。
   	void remove( )  //删除对应这个线程的值。
   	static <S> ThreadLocal <S> withlnitial(Supplier<? extends S> supplier)
   	//创建一个线程局部变量， 其初始值通过调用给定的 supplier 生成。
   
   java.util.concurrent.ThreadLocalRandom 
   	static ThreadLocalRandom current( )  //返回特定于当前线程的 Random 类实例。
   ```

5.13  锁测试与超时

1. 线程在调用 lock 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。应该更加谨慎地申请锁。

2. tryLock 方法试图申请一个锁， 在成功获得锁后返回 true, 否则， 立即返回false, 而且线程可以立即离开去做其他事情。可以调用 tryLock 时，使用超时参数

   ```java
   if (myLock.tryLock())
   {
   // now the thread owns the lock
   try { . . . }
   finally { myLock.unlock(); }
   }
   else
   // do something else
    
   if (myLock.tryLock(100, TineUnit.MILLISECONDS)) .. .
       //TimeUnit 是一枚举类型，可以取的值包括 SECONDS、MILLISECONDS, MICROSECONDS和 NANOSECONDS。
   ```

3. lock 方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁， 那么， lock 方法就无法终止。

4. 如果调用带有用超时参数的 tryLock, 那么如果线程在等待期间被中断，将抛出InterruptedException 异常。这是一个非常有用的特性，因为允许程序打破死锁。

5. 也可以调用 locklnterruptibly 方法。它就相当于一个超时设为无限的 tryLock 方法。

6. 在等待一个条件时， 也可以提供一个超时：myCondition.await(100, TineUniBILLISECONDS))

7. 如果一个线程被另一个线程通过调用 signalAU 或 signal 激活， 或者超时时限已达到， 或者线程被中断， 那么 await 方法将返回。

8. 如果等待的线程被中断， await 方法将抛出一个 InterruptedException 异常。在你希望出现这种情况时线程继续等待（可能不太合理)， 可以使用 awaitUninterruptibly 方法代替 await。

```java
java.util.concurrent.locks.Lock 
	boolean tryLock()  /*尝试获得锁而没有发生阻塞；如果成功返回真。这个方法会抢夺可用的锁， 即使该锁
	有公平加锁策略， 即便其他线程已经等待很久也是如此。*/
	boolean tryLock(long time, TimeUnit unit)  //尝试获得锁，阻塞时间不会超过给定的值；如果成功返回 true。
	void lockInterruptibly()  //获得锁， 但是会不确定地发生阻塞。 如果线程被中断， 抛出一个 InterruptedException异常。

java.util.concurrent.locks.Condition 
	boolean await( long time , TimeUnit unit )  /*进人该条件的等待集， 直到线程从等待集中移出或等待了指定的时间之后才解除阻
	塞。 如果因为等待时间到了而返回就返回 false, 否 则 返 回 true。*/
	void awaitUninterruptibly( )  /*进人该条件的等待集， 直到线程从等待集移出才解除阻塞。 如果线程被中断， 该方法
	不会抛出 InterruptedException 异常。*/
```

### 5.14  读 / 写锁

1. java.util.concurrent.locks 包 定 义 了 两 个 锁 类，  ReentrantLock 类 和ReentrantReadWriteLock 类。

2. 如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话， 后者是十分有用的。在这种情况下， 允许对读者线程共享访问是合适的。当然， 写者线程依然必须是互斥访问的。

3. 使用读 / 写锁的必要步骤：

   ```java
   java.util.concurrent.locks.ReentrantReadWriteLock 
   //(1) 构 造 一 个 ReentrantReadWriteLock 对象：
   	private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
   //(2) 抽取读锁和写锁：
   	private Lock readLock = rwl.readLock();  //得到一个可以被多个读操作共用的读锁， 但会排斥所有写操作。
   	private Lock writeLock = rwl.writeLock();  //得到一个写锁， 排斥所有其他的读操作和写操作。
   //(3) 对所有的获取方法加读锁：
   	public double getTotalBalance(){
   		readLock.lock();
   		try { . . . }
   		finally { readLock.unlock(); }
   	}
   //(4) 对所有的修改方法加写锁
   	public void transfer(. . .){
   		writeLock.lock();
   		try { . . . }
   		finally { writeLock.unlock(); }
   	}
   ```

   

### 5.15  为什么弃用 stop 和 suspend 方法

1. 初始的 Java 版本定义了一个 stop 方法用来终止一个线程， 以及一个 suspend 方法用来阻塞一个线程直至另一个线程调用 resume。stop 和 suspend 方法有一些共同点： 都试图控制一个给定线程的行为。
2. stop、 suspend 和 resume 方法已经弃用。stop 方法天生就不安全，经验证明 suspend 方法会经常导致死锁。
   -  stop 方法， 该方法终止所有未结束的方法， 包括 run 方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。
   - 当线程要终止另一个线程时， 无法知道什么时候调用 stop 方法是安全的， 什么时候导致对象被破坏。 因此，该方法被弃用了。在希望停止线程的时候应该中断线程， 被中断的线程会在安全的时候停止。
   - 从技术上讲， 被停止的线程通过抛出 ThreadDeath 异常退出所有它所调用的同步方法。 结果是， 该线程释放它持有的内部对象锁。
3. 与 stop 不同，suspend 不会破坏对象。但是，如果用 suspend 挂起一个持有一个锁的线程， 那么，该锁在恢复之前是不可用的。 如果调用suspend 方法的线程试图获得同一个锁， 那么程序死锁： 被挂起的线程等着被恢复， 而将其挂起的线程等待获得锁。
4. 如果想安全地挂起线程， 引人一个变量 suspendRequested 并在 run 方法的某个安全的地方测试它， 安全的地方是指该线程没有封锁其他线程需要的对象的地方。 当该线程发现suspendRequested 变量已经设置， 将会保持等待状态直到它再次获得为止。

## 6  阻塞队列

1. 对于实际编程来说，应该尽可能远离底层结构。使用由并发处理的专业人士实现的较高层次的结构要方便得多、 要安全得多。

2. 对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插人元素， 消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。

   例如， 考虑银行转账程序， 转账线程将转账指令对象插入一个队列中，而不是直接访问银行对象。 另一个线程从队列中取出指令执行转账。只有该线程可以访问该银行对象的内部。 因此不需要同步。

3. 当试图向队列添加元素而队列已满， 或是想从队列移出元素而队列为空的时候， 阻塞队列（blocking queue) 导致线程阻塞。

4. 在协调多个线程之间的合作时， 阻塞队列是一个有用的工具。工作者线程可以周期性地将中间结果存储在阻塞队列中。其他的工作者线程移出中间结果并进一步加以修改。队列会自动地平衡负载。如果第一个线程集运行得比第二个慢， 第二个线程集在等待结果时会阻塞。 如果第一个线程集运行得快， 它将等待第二个队列集赶上来。

5. 阻塞队列的方法。

   ![阻塞队列的方法](E:\pogject\javalearn\学习笔记\img\阻塞队列的方法.png)

6. 阻塞队列方法分为以下 3 类， 这取决于当队列满或空时它们的响应方式。

   - 如果将队列当作线程管理工具来使用， 将要用到 put 和 take 方法。
   - 当试图向满的队列中添加或从空的队列中移出元素时，add、 remove 和 element 操作抛出异常。
   - 当然，在一个多线程程序中， 队列会在任何时候空或满， 因此，一定要使用 offer、 poll 和 peek 方法作为替代。这些方法如果不能完成任务，只是给出一个错误提示而不会抛出异常。poll 和 peek 方法返回空来指示失败。 因此，向这些队列中插入 null 值是非法的。

7. 还有带有超时的 offer 方法和 poll 方法的变体。如果队列满， 则 put 方法阻塞； 如果队列空， 则 take 方法阻塞。在不带超时参数时，offer 和 poll 方法等效。

8. java.util.concurrent 包提供了阻塞队列的几个变种。

   - 默认情况下，LinkedBlockingQueue的容量是没有上边界的，但是，也可以选择指定最大容量。

   - LinkedBlockingDeque 是一个双端的版本。

   - ArrayBlockingQueue 在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数， 则那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能， 只有在确实非常需要时才使用它。

   - PriorityBlockingQueue 是一个带优先级的队列， 而不是先进先出队列。元素按照它们的优先级顺序被移出。 该队列是没有容量上限， 但是，如果队列是空的， 取元素的操作会阻塞。

   - 最后， DelayQueue 包含实现 Delayed 接口的对象：

     ```java
     interface Delayed extends Comparable<Delayed>
     {
     	long getDelay(TimeUnit unit);
     }
     ```

     getDelay 方法返回对象的残留延迟。 负值表示延迟已经结束。元素只有在延迟用完的情况下才能从 DelayQueue 移除。还必须实现 compareTo 方法。DelayQueue 使用该方法对元素进行排序。

   - avaSE 7 增加了一个 TranSferQueUe 接口，允许生产者线程等待， 直到消费者准备就绪可以接收一个元素。 如果生产者调用

     **q.transfer(iteni);**  这个调用会阻塞， 直到另一个线程将元素（item) 删除。LinkedTransferQueue 类实现了这个接口。

     

     程序展示了如何使用阻塞队列来控制一组线程。程序在一个目录及它的所有子目录下搜索所有文件， 打印出包含指定关键字的行。

     ```java
     import java.io.*;
     import java.util.*;
     import java.util.concurrent.*;
     
     public class TestSynchBase2{
     	public static final int FILE_QUEUE_SIZE=10;
     	public static final int SEARCH_THREADS=100;
     	public static final File DUMMY=new File("");
     	//构造一个带有指定的容量和公平性设置的阻塞队列。该队列用循环数组实现。
     	public static BlockingQueue<File> queue=new ArrayBlockingQueue<>(FILE_QUEUE_SIZE);
     	//public static int totalNumber=0;
     	public static void main(String[] args) {
     		String directory="../javahighrank";
     		String keyword="mane";
     
     		Runnable enumerator=()->{
     			try{
     				enumerate(new File(directory));
     				//添加元素， 在必要时阻塞
     				queue.put(DUMMY);
     			}catch(InterruptedException e){
     				e.printStackTrace();
     			}
     		};
     		new Thread(enumerator).start();
     		for (int i=1; i<=SEARCH_THREADS; i++) {
     			Runnable searcher=()->{
     				try{
     					boolean done=false;
     					while (!done){
     						File file=queue.take();
     						if (file==DUMMY) {
     							queue.put(file);
     							done=true;
     						}else{
     							search(file,keyword);
     						}
     					}
     				}catch(IOException e){
     					e.printStackTrace();
     				}catch (InterruptedException e){
     					e.printStackTrace();
     				}
     			};
     			new Thread(searcher).start();
     		}
     	}
     	public static void enumerate(File directory) throws InterruptedException{
     		File[] files=directory.listFiles();
     		for (File file:files){
     			if (file.isDirectory()) {
     				enumerate(file);
     			}else{
     				queue.put(file);
     			}
     		}
     	}
     	public static void search(File file,String keyword) throws IOException{
     		try (Scanner in=new Scanner(file,"UTF-8")){
     			int lineNumber=0;
     			while (in.hasNextLine()){
     				lineNumber++;
     				String line=in.nextLine();
     				if (line.contains(keyword)) {
     					System.out.printf("%s:%d:%s%n", file.getPath(),lineNumber,line);
     				}
     			}
     		}
     	}
     }
     ```

     

## 7  线程安全的集合

​     

​     

