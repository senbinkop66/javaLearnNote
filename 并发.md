# 并发

1. 并发执行的进程数目并不是由 CPU 数目制约的。操作系统将 CPU 的时间片分配给每一个进程， 给人并行处理的感觉。
2. 多线程程序在较低的层次上扩展了多任务的概念： 一个程序同时执行多个任务。通常，每一个任务称为一个线程（thread), 它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序（multithreaded)。
3. 多进程与多线程有哪些区别呢？ 本质的区别在于每个进程拥有自己的一整套变量， 而线程则共享数据。 
   - 共享变量使线程之间的通信比进程之间的通信更有效、 更容易。
   - 此外， 在有些操作系统中， 与进程相比较， 线程更“ 轻量级”， 创建、 撤销一个线程比启动新进程的开销要小得多。

## 1  什么是线程

1. 调用 Threadsleep 不会创建一个新线程，sleep 是 Thread 类的静态方法，用于暂停当前线程的活动。
2. sleep 方法可以抛出一个 IntermptedException 异常。

```java
import java.util.*;
import java.time.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.geom.*;

class Ball{
	private static final int XSIZE=15;
	private static final int YSIZE=15;
	private double x=0;
	private double y=0;
	private double dx=1;
	private double dy=1;

	public void move(Rectangle2D bounds){
		x+=dx;
		y+=dy;
		if (x<bounds.getMinX()) {
			x=bounds.getMinX();
			dx=-dx;
		}
		if (x+XSIZE>=bounds.getMaxX()) {
			x=bounds.getMaxX()-XSIZE;
			dx=-dx;
		}
		if (y<bounds.getMinY()) {
			y=bounds.getMinY();
			dy=-dy;
		}
		if (y+YSIZE>=bounds.getMaxY()) {
			y=bounds.getMaxY()-YSIZE;
			dy=-dy;
		}
	}
	public Ellipse2D getShape(){
		return new Ellipse2D.Double(x,y,XSIZE,YSIZE);
	}
}

class BallComponent extends JPanel{
	private static final int DEFAULT_WIDTH=600;
	private static final int DEFAULT_HEIGHT=600;

	private java.util.List<Ball> balls=new ArrayList<>();

	public void add(Ball b){
		balls.add(b);
	}

	public void paintComponent(Graphics g){
		super.paintComponent(g);
		Graphics2D g2=(Graphics2D) g;
		g2.setPaint(Color.BLUE);
		for (Ball b:balls){
			g2.fill(b.getShape());
		}
	}
	public Dimension getPreferredSize(){
		return new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT);
	}
}

class BounceFrame extends JFrame{
	private BallComponent comp;
	public static final int STEPS=1000;
	public static final int DELAY=3;

	public BounceFrame(){
		comp=new BallComponent();
		add(comp,BorderLayout.CENTER);
		JPanel buttonPanel=new JPanel();
		addButton(buttonPanel,"Start",event->addBall());
		addButton(buttonPanel,"Close",event->System.exit(0));
		add(buttonPanel,BorderLayout.SOUTH);
		pack();
	}

	public void addButton(Container c,String title,ActionListener listener){
		JButton button=new JButton(title);
		c.add(button);
		button.addActionListener(listener);
	}

	public void addBall(){
		try{
			Ball ball=new Ball();
			comp.add(ball);
			for (int i=1; i<=STEPS; i++) {
				ball.move(comp.getBounds());
				comp.paint(comp.getGraphics());
				Thread.sleep(DELAY);
			}
		}catch(InterruptedException e){
			e.printStackTrace();
		}
	}
}

public class TestBase9{
	public static void main(String[] args) {
		EventQueue.invokeLater(()->{
			JFrame frame=new BounceFrame();
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setTitle("弹球");  //设置框架标题
			frame.setLocation(300,300);
			frame.setVisible(true);  //使其可见性
		});
	}
}
```

### 1.1  使用线程给其他任务提供机会

1. 可以将移动球的代码放置在一个独立的线程中， 运行这段代码可以提高弹跳球的响应能力。实际上，可以发起多个球， 每个球都在自己的线程中运行。另外，AWT 的事件分派线程( event dispatch thread) 将一直地并行运行， 以处理用户界面的事件。由于每个线程都有机会得以运行，所以在球弹跳期间， 当用户点击 Close 按钮时， 事件调度线程将有机会关注到这个事件， 并处理“ 关闭” 这一动作。

```java
public void addBall(){
		Ball ball=new Ball();
		comp.add(ball);
		Runnable r=()->{
			try{
				for (int i=1; i<=STEPS; i++) {
					ball.move(comp.getBounds());
					comp.repaint();
					Thread.sleep(DELAY);
				}
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		};
		Thread t=new Thread(r);
		t.start();
	}
```
2. 在一个单独的线程中执行一个任务的简单过程：

   - 将任务代码移到实现了 Runnable 接口的类的 run 方法中。这个接口非常简单， 只有一个方法：

     public interface Runnable
     {
     	void run()；
     }

     由于 Runnable 是一个函数式接口，可以用 lambda 表达式建立一个实例：Runnable r = () -> { task code };

   - 由 Runnable 创建一个 Thread 对象： Thread t = new Thread(r);

   - 启动线程：t.start()；

3. 也可以通过构建一个 Thread 类的子类定义一个线程，

   ```
   class MyThread extends Thread
   {
       public void run()
       {
       task code
       }
   }
   ```

   然后， 构造一个子类的对象， 并调用 start 方法。 不过， 这种方法已不再推荐。 应该将要并行运行的任务与运行机制解耦合。如果有很多任务， 要为每个任务创建一个独立的线程所付出的代价太大了。 可以使用线程池来解决这个问题，

4. 不要调用 Thread 类或 Runnable 对象的 run 方法。 直接调用 run 方法， 只会执行同一个线程中的任务， 而不会启动新线程。 应该调用 Thread.start 方法。这个方法将创建一个执行 run 方法的新线程。

```java
java.lang.Thread
	Thread(Runnable target )  //构造一个新线程， 用于调用给定目标的 run() 方法。
	void start( )  //启动这个线程， 将引发调用 run() 方法。这个方法将立即返回， 并且新线程将并发运行。
	void run( )  //调用关联 Runnable 的 run 方法。
    void interrupt()  /*向线程发送中断请求。线程的中断状态将被设置为 true。如果目前该线程被一个 sleep调用阻塞，那么， InterruptedException 异常被抛出。*/
	static boolean interrupted()  /*测试当前线程（即正在执行这一命令的线程）是否被中断。注意，这是一个静态方法。	这一调用会产生副作用—它将当前线程的中断状态重置为 false。*/
	boolean isInterrupted()  //测试线程是否被终止。不像静态的中断方法，这一调用不改变线程的中断状态。
	static Thread currentThread()  //返回代表当前执行线程的 Thread 对象。
    void join( )  //等待终止指定的线程。
	void join(long mi11is)  //等待指定的线程死亡或者经过指定的毫秒数。
	Thread.State getState()  //得到这一线程的状态；NEW、RUNNABLE、BLOCKED、 WAITING、TIMED_WAITING或 TERMINATED 之一。
	void stop()  //停止该线程。这一方法已过时。
    void suspend()  //暂停这一线程的执行
	void resume()  //恢复线程。这一方法仅仅在调用 suspendO 之后调用。这一方法已过时。
    void setPriority(int newPriority)  //设置线程的优先级。
	static int MIN_PRIORITY  //线程的最小优先级。最小优先级的值为 1。
	static int N0RM_PRI0RITY  //线程的默认优先级。默认优先级为 5。
	static int MAX_PRIORITY  //线程的最高优先级。最高优先级的值为 10。
	static void yield( )  /*导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高
	的优先级，那么这些线程接下来会被调度。注意，这是一个静态方法。*/
    void setDaemon( boolean isDaemon )  //标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。

java.lang.Runnable
	void run( )  //必须覆盖这个方法， 并在这个方法中提供所要执行的任务指令。
```

## 2  中 断 线 程

1. 当线程的 run 方法执行方法体中最后一条语句后， 并经由执行 return 语句返冋时， 或者出现了在方法中没有捕获的异常时， 线程将终止。 

2. 没有可以强制线程终止的方法。然而， interrupt 方法可以用来请求终止线程。

3. 当对一个线程调用 interrupt 方法时，线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该不时地检査这个标志， 以判断线程是否被中断。

   要想弄清中断状态是否被置位， 首先调用静态的 Thread.currentThread 方法获得当前线程， 然后调用 islnterrupted 方法：

   ```java
   while (!Thread.currentThread().islnterrupted() && more work to do)
   {
   	do more work
   }
   ```

   但是， 如果线程被阻塞， 就无法检测中断状态。 这是产生 InterruptedExceptioii 异常的地方。

4. 当在一个被阻塞的线程 （调用 sleep 或 wait) 上调用 interrupt 方法时， 阻塞调用将会被Interrupted Exception 异常中断。（存在不能被中断的阻塞 I/O 调用， 应该考虑选择可中断的调用。)

5. 没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后， 继续执行， 而不理会中断。

6. 更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的 run 方法具有如下形式：

   ```java
   Runnable r = () -> {
   	try{
   		...;
   		while (!Thread.currentThread().islnterrupted0 && more work todo){
   			do more work
   		}
   	}catch(InterruptedException e){
   		// thread was interrupted during sleep or wait
   	}finally{
   		cleanup,if required
   	}
   	// exiting the run method terminates the thread
   };
   ```

   如果在每次工作迭代之后都调用 sleep 方法（或者其他的可中断方法 )， islnterrupted 检测 既没有必要也没有用处。 如果在中断状态被置位时调用 sleep 方法， 它不会休眠。 相反，它 将清除这一状态（!）并拋出 IntemiptedException。因此， 如果你的循环调用 sleep， 不会检 测中断状态。相反，要如下所示捕获 InterruptedException 异常：

   ```java
   Runnable r = () -> {
   	try{
   		...;
   		while (!Thread.currentThread().islnterrupted0 && more work todo){
   			do more work
   			Thread.sleep(delay);
   		}
   	}catch(InterruptedException e){
   		// thread was interrupted during sleep
   	}finally{
   		cleanup,if required
   	}
   	// exiting the run method terminates the thread
   };
   ```

7. Interrupted 方法是一个静态方法， 它检测当前的线程是否被中断。 而且， 调用 interrupted 方法会清除该线程的中断状态。 另一方面， islnterrupted 方法是一个实例方法， 可用来检验是否有线程被中断。调用这个方法不会改变中断状态。

8. 在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。

   ```java
   void mySubTask(){
   	...
   	try { sleep(delay); }
   	catch (InterruptedException e) { Thread.currentThread().interrupt(); }
   	...
   }
   ```

9. 或者， 更好的选择是， 用 throws InterruptedException 标记你的方法， 不采用 try 语句块捕获异常。于是， 调用者（或者， 最终的 run 方法）可以捕获这一异常。

   ```java
   void mySubTask() throws InterruptedException{
   	...
   	sleep(delay);
   	...
   }
   ```

   

## 3  线程状态

线程可以有如下 6 种状态：要确定一个线程的当前状态， 可调用 getState 方法。

- New (新创建）
- Runnable (可运行）
- Blocked ( 被阻塞）
- Waiting (等待）
- Timed waiting (计时等待）
- Terminated (被终止）

### 3.1  新创建线程

1. 当用 new 操作符创建一个新线程时， 如 newThread(r)， 该线程还没有开始运行。这意味着它的状态是 new。当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

### 3.2  可运行线程

1. 一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线桿可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。（Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态。）
2. 一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。
3. 线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。 当时间片用完， 操作系统剥夺该线程的运行权， 并给另一个线程运行机会。当选择下一个线程时， 操作系统考虑线程的优先级。
4. 现在所有的桌面以及服务器操作系统都使用抢占式调度。但是， 像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 yield 方法、 或者被阻塞或等待时，线程才失去控制权。
5. 在具有多个处理器的机器上， 每一个处理器运行一个线程， 可以有多个线程并行运行。当然， 如果线程的数目多于处理器的数目， 调度器依然采用时间片机制。
6. 在任何给定时刻，二个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行)。

### 3.3  被阻塞线程和等待线程

1. 当线程处于被阻塞或等待状态时， 它暂时不活动。 它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。 细节取决于它是怎样达到非活动状态的。
   - 当一个线程试图获取一个内部的对象锁（而不是 javiutiUoncurrent 库中的锁)， 而该锁被其他线程持有， 则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
   - 当线程等待另一个线程通知调度器一个条件时， 它自己进入等待状态。在调用 Object.wait 方法或 Thread.join 方法， 或者是等待 java,util.concurrent 库中的 Lock 或 Condition 时， 就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。
   - 有几个方法有一个超时参数。调用它们导致线程进人计时等待（ timed waiting) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep 和 Object.wait、 Thread.join、 Lock,tryLock 以及 Condition.await 的计时版。

### 3.4  被终止的线程

1. 线程因如下两个原因之一而被终止：
   - 因为 run 方法正常退出而自然死亡。
   - 因为一个没有捕获的异常终止了 nm 方法而意外死亡。

线程状态

![线程状态](E:\pogject\javalearn\学习笔记\img\线程状态.png)

当一个线程被阻塞或等待时（或终止时)， 另一个线程被调度为运行状态。当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁)，调度器检查它是否具有比当前运行线程更高的优先级。 如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。

## 4  线 程 属 性

### 4.1  线程优先级

1. 在 Java 程序设计语言中， 每一个线程有一个优先级。 默认情况下， 一+线程继承它的父线程的优先级。 
2. 可以用 setPriority 方法提高或降低任何一个线程的优先级。可以将优先级设 置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的 任何值。NORM_PRIORITY 被定义为 5。
3. 每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。 当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多，也许更少。
4. 不要将程序构建为功能的正确性依赖于优先级。如果有几个高优先级的线程没有进入非活动状态， 低优先级的线程可能永远也不能执行。每当调度器决定运
   行一个新线程时， 首先会在具有高优先级的线程中进行选择， 尽管这样会使低优先级的线程完全饿死。

### 4.2  守护线程

1. 可以通过调用 **t.setDaemon(true)** ;将线程转换为守护线程（daemon thread)。
2. 守护线程的唯一用途是为其他线程提供服务。计时线程就是一个例子，它定时地发送“ 计时器嘀嗒” 信号给其他线程或清空过时的高速缓存项的线程。当只剩下守护线程时， 虚拟机就退出了， 由于如果只剩下守护线程， 就没必要继续运行程序了。
3. 守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

### 4.3  未捕获异常处理器

1. 线程的 run 方法不能抛出任何受查异常， 但是，非受査异常会导致线程终止。在这种情况下，线程就死亡了。
2. 不需要任何 catch 子句来处理可以被传播的异常。 相反， 就在线程死亡之前， 异常被传递到一个用于未捕获异常的处理器。该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类。这个接口只有—个方法。 **void uncaughtException(Thread t, Throwable e)**
3. 可以用 setUncaughtExceptionHandler 方法为任何线程安装一个处理器。也可以用 Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有线程安装一个默认的处理器。 替换处理器可以使用日志 API 发送未捕获异常的报告到日志文件。
4. 如果不安装默认的处理器， 默认的处理器为空。 但是， 如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。
5. 线程组是一个可以统一管理的线程集合。默认情况下， 创建的所有线程属于相同的线程组， 但是， 也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。
6. ThreadGroup 类实现 Thread.UncaughtExceptionHandler 接口。 它的 uncaughtException 方法做如下操作：
   - 如果该线程组有父线程组， 那么父线程组的 uncaughtException 方法被调用。
   - 否则， 如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器， 则调用该处理器。
   - 否则， 如果 Throwable 是 ThreadDeath 的一个实例， 什么都不做。
   - 否则， 线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。（但是， 如果 e 是一个 ThreadDeath对象， 栈轨迹是被禁用的。)

```java
java.lang.Thread
	static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) 
	static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()
	//设置或获取未捕获异常的默认处理器。
	void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)
	Thread.UncaughtExceptionHandler getUncaughtExceptionHandler( )
	//设置或获取未捕获异常的处理器。 如果没有安装处理器， 则将线程组对象作为处理器。
java.lang.Thread.UncaughtExceptionHandler 
	void UncaughtException(Thread t, Throwable e)  //当一个线程因未捕获异常而终止， 按规定要将客户报告记录到日志中。

java.lang.ThreadGroup
	void UncaughtException(Thread t, Throwable e)  /**/
```



##  5  同 步

### 5.1  竞争条件的产生

1. 在大多数实际的多线程应用中， 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象， 并且每一个线程都调用了一个修改该对象状态的方法，将会发 生什么呢？ 可以想象， 线程彼此踩了对方的脚。 根据各线程访问数据的次序， 可能会产生i化 误的对象。这样一个情况通常称为竞争条件（race condition)。

   非同步存取银行账户

   ```java
   import java.util.*;
   
   class Bank{
   	private final double[] accounts;
   
   	public Bank(int n,double initialBalance){
   		accounts=new double[n];
   		Arrays.fill(accounts,initialBalance);
   	}
   
   	public void transfer(int from,int to,double amount){
   		if (accounts[from]<amount) return;
   		System.out.print(Thread.currentThread());
   		accounts[from]-=amount;
   		System.out.printf(" %10.2f from %d to %d",amount,from,to);
   		accounts[to]+=amount;
   		System.out.printf(" 总额: %10.2f%n",getTotalBalance());
   	}
   	public double getTotalBalance(){
   		double sum=0;
   		for (double a:accounts){
   			sum+=a;
   		}
   		return sum;
   	}
   	public int size(){
   		return accounts.length;
   	}
   }
   
   public class TestSynchBase1{
   	public static final int NACCOUNTS=100;
   	public static final double INITIAL_BALANCE=1000;
   	public static final double MAX_AMOUNT=1000;
   	public static final int DELAY=10;
   
   	public static void main(String[] args) {
   		Bank bank=new Bank(NACCOUNTS,INITIAL_BALANCE);
   		for (int i=0; i<NACCOUNTS; i++) {
   			int fromAccount=i;
   			Runnable r=()->{
   				try{
   					while(true){
   						int toAccount=(int) (bank.size()*Math.random());
   						double amount=MAX_AMOUNT*Math.random();
   						bank.transfer(fromAccount,toAccount,amount);
   						Thread.sleep((int)(DELAY*Math.random()));
   					}
   				}catch (InterruptedException e){
   					e.printStackTrace();
   				}
   			};
   			Thread t=new Thread(r);
   			t.start();
   		}
   	}
   }
   ```

   

### 5.2  竞争条件详解

1. 真正的问题是 transfer 方法的执行过程中可能会被中断。 如果能够确保线程在失去控制之前方法运行完成， 那么银行账户对象的状态永远不会出现讹误。

### 5.3  锁对象

1. 有两种机制防止代码块受并发访问的干扰。Java 语言提供一个 synchronized 关键字达到这一目的， 并且 Java SE 5.0 引入了 ReentrantLock 类。synchronized 关键字自动提供一个锁以及相关的“ 条件”， 对于大多数需要显式锁的情况， 这是很便利的。

2. 用 ReentrantLock 保护代码块的基本结构如下：

   ```java
   myLock.lock(); // a ReentrantLock object
   try{
   	critical section
   }finally{
   	myLock.unlock()；// make sure the lock is unlocked even if an exception is thrown
   }
   ```

   这一结构确保任何时刻只有一个线程进人临界区。一旦一个线程封锁了锁对象， 其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞， 直到第一个线程释放锁对象。

3. 把解锁操作括在 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。 否则， 其他线程将永远阻塞。

4. 如果使用锁， 就不能使用带资源的 try 语句。首先， 解锁方法名不是 close。不过，即使将它重命名， 带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁， 你可能想使用多个线程共享的那个变量（而不是新变量）。

5. 锁是可重入的， 因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（ hold count) 来跟踪对 lock 方法的嵌套调用。线程在每一次调用 lock 都要调用 unlock 来释放锁。由于这一特性， 被一个锁保护的代码可以调用另一个使用相同的锁的方法。

6. 通常， 可能想要保护需若干个操作来更新或检查共享对象的代码块。要确保这些操作完成后， 另一个线程才能使用相同对象。

7. 要留心临界区中的代码， 不要因为异常的抛出而跳出临界区。 如果在临界区代码结束之前抛出了异常， finally 子句将释放锁，但会使对象可能处于一种受损状态。

   **加锁同步存取银行账户**

   ```java
   import java.util.concurrent.locks.Lock;
   import java.util.concurrent.locks.ReentrantLock;
   	public void transfer(int from,int to,double amount){
   		if (accounts[from]<amount) return;
   		bankLock.lock();
   		try{
   			System.out.print(Thread.currentThread());
   			accounts[from]-=amount;
   			System.out.printf(" %10.2f from %d to %d",amount,from,to);
   			accounts[to]+=amount;
   			System.out.printf(" 总额: %10.2f%n",getTotalBalance());
   		}finally{
   			bankLock.unlock();
   		}
   	}	
   import java.util.concurrent.locks.Lock;
   	void lock( )  //获取这个锁；如果锁同时被另一个线程拥有则发生阻塞。
   	void unlock( )  //释放这个锁。
   import java.util.concurrent.locks.ReentrantLock;
   	ReentrantLock( )  //构建一个可以被用来保护临界区的可重入锁。
   	ReentrantLock(boo1ean fair )  /*构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。 但是，这一公平
   	的保证将大大降低性能。 所以， 默认情况下， 锁没有被强制为公平的。*/
   
   ```

8. 即使使用公平锁， 也无法确保线程调度器是公平的。 如果线程调度器选择忽略一个线程， 而该线程为了这个锁已经等待了很长时间， 那么就没有机会公平地处理这个锁了。

### 5.4  条件对象

1. 通常， 线程进人临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。（由于历史的原因， 条件对象经常被称为条件变量（conditionalvariable)。）

2. 一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。

3. 等待获得锁的线程和调用 await 方法的线程存在本质上的不同。一旦一个线程调用 await方法， 它进人该条件的等待集。 当锁可用时，该线程不能马上解除阻塞。 相反，它处于阻塞状态，直到另一个线程调用同一条件上的 signalAll 方法时为止。

4. 当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时， 它们将试图重新进人该对象。一旦锁成为可用的，它们中的某个将从 await 调用返回， 获得该锁并从被阻塞的地方继续执行。

5. 此时， 线程应该再次测试该条件。 由于无法确保该条件被满足—signalAll 方法仅仅是通知正在等待的线程：此时有可能已经满足条件， 值得再次去检测该条件。

6. 通常， 对 await 的调用应该在如下形式的循环体中

   ```
   while (!(ok to proceed) )
   	condition.await();
   ```

7. 当一个线程调用 await 时， 它 没有办法重新激活自身。它寄希望于其他线程。 如果没有其他线程来重新激活等待的线程， 它就永远不再运行了。这将导致令人不快的死锁（deadlock) 现象。 如果所有其他线程被阻 塞， 最后一个活动线程在解除其他线程的阻塞状态之前就调用 await 方法， 那么它也被阻塞。 没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。

8. 应该何时调用 signalAll 呢？ 经验上讲， 在对象的状态有利于等待线程的方向改变时调用signalAll。例如， 当一个账户余额发生改变时， 等待的线程会应该有机会检查余额。在例子中， 当完成了转账时， 调用 signalAll 方法。

9. 注意调用 signalAll 不会立即激活一个等待线程。它仅仅解除等待线程的阻塞， 以便这些线程可以在当前线程退出同步方法之后， 通过竞争实现对对象的访问。

10. 另一个方法 signal, 则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。 如果随机选择的线程发现自己仍然不能运行， 那么它再次被阻塞。如果没有其他线程再次调用 signal, 那么系统就死锁了。

11. 当一个线程拥有某个条件的锁时， 它仅仅可以在该条件上调用 await、signalAll 或signal 方法。

```java
class Bank{
	private final double[] accounts;
	private Lock bankLock;
	private Condition sufficientFunds;

	public Bank(int n,double initialBalance){
		accounts=new double[n];
		Arrays.fill(accounts,initialBalance);
		bankLock=new ReentrantLock();
		sufficientFunds=bankLock.newCondition();
	}

	public void transfer(int from,int to,double amount) throws InterruptedException{
		bankLock.lock();
		try{
			while(accounts[from]<amount){
				sufficientFunds.await();
			}
			System.out.print(Thread.currentThread());
			accounts[from]-=amount;
			System.out.printf(" %10.2f from %d to %d",amount,from,to);
			accounts[to]+=amount;
			System.out.printf(" 总额: %10.2f%n",getTotalBalance());
			sufficientFunds.signalAll();
		}finally{
			bankLock.unlock();
		}
	}
	public double getTotalBalance(){
		bankLock.lock();
		try{
			double sum=0;
			for (double a:accounts){
				sum+=a;
			}
			return sum;
		}finally{
			bankLock.unlock();
		}
	}
	public int size(){
		return accounts.length;
	}
}

java.util.concurrent.locks.Lock
	Condition newCondition( )  //返回一个与该锁相关的条件对象。
java.util.concurrent.locks.Condition
	void await( )  //将该线程放到条件的等待集中。
	void signalA11( )  //解除该条件的等待集中的所有线程的阻塞状态。
	void signal ( )  //从该条件的等待集中随机地选择一个线程， 解除其阻塞状态。
```

### 5.5  synchronized 关键字

1. 有关锁和条件的关键之处：

   - 锁用来保护代码片段， 任何时刻只能有一个线程执行被保护的代码。
   - 锁可以管理试图进入被保护代码段的线程。
   - 锁可以拥有一个或多个相关的条件对象。
   - 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

2. Lock 和 Condition 接口为程序设计人员提供了高度的锁定控制。然而， 大多数情况下，并不需要那样的控制，并且可以使用一种嵌人到 Java 语言内部的机制。

   ```java
   public synchronized void method(){
   	method body
   }
   //等价于
   public void method(){
   	this.intrinsicLock.lock();
   	try{
   		method body
   	}finally{
   		this.intrinsicLock.unlock();
   	}
   }
   ```

   

3. 从 1.0 版开始，Java中的每一个对象都有一个内部锁。 如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法， 线程必须获得内部的对象锁。例如， 可以简单地声明 Bank 类的 transfer 方法为 synchronized, 而不是使用一个显式的锁。

4. 内部对象锁只有一个相关条件。wait 方法添加一个线程到等待集中，notifyAU /notify 方法解除等待线程的阻塞状态。换句话说，调用 wait 或 notityAll 等价于

   **intrinsicCondition.await();**
   **intrinsicCondition.signalAIl();**

5. wait、notifyAll 以及 notify 方法是 Object 类的 final 方法。Condition 方法必须被命名为 await、signalAll 和 signal 以便它们不会与那些方法发生冲突。

```java
	public synchronized void transfer(int from,int to,double amount) throws InterruptedException{
			while(accounts[from]<amount){
				wait();
			}
			System.out.print(Thread.currentThread());
			accounts[from]-=amount;
			System.out.printf(" %10.2f from %d to %d",amount,from,to);
			accounts[to]+=amount;
			System.out.printf(" 总额: %10.2f%n",getTotalBalance());
			notifyAll();
	}
	public synchronized double getTotalBalance(){
		double sum=0;
		for (double a:accounts){
			sum+=a;
		}
		return sum;
	}

java.lang.Object 
	void notifyAll()  /*解除那些在该对象上调用 wait 方法的线程的阻塞状态。该方法只能在同步方法或同步块内
	部调用。 如果当前线程不是对象锁的持有者，该方法拋出一个 IllegalMonitorStateException异常。*/
	void notify( )  /*随机选择一个在该对象上调用 wait 方法的线程， 解除其阻塞状态。该方法只能在一个同步方法或同步块中调用。 */
	void wait( )  //导致线程进人等待状态直到它被通知。该方法只能在一个同步方法中调用。
	void wait(long mi11is)
	void wait(long millis, int nanos )  //导致线程进入等待状态直到它被通知或者经过指定的时间。
```

使用 synchronized 关键字来编写代码要简洁得多。 当然， 要理解这一代码， 必须了解每一个对象有一个内部锁， 并且该锁有一个内部条件。由锁来管理那些试图进入synchronized 方法的线程， 由条件来管理那些调用 wait 的线程。

6. 将静态方法声明为 synchronized 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如， 如果 Bank 类有一个静态同步的方法，那么当该方法被调用时，Bank.class对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。
7. 内部锁和条件存在一些局限。包括：
   - 不能中断一个正在试图获得锁的线程。
   - 试图获得锁时不能设定超时。
   - 每个锁仅有单一的条件， 可能是不够的。
8. 在代码中应该使用哪一种？ Lock 和 Condition 对象还是同步方法？下面是一些建议：
   - 最好既不使用 Lock/Condition 也不使用 synchronized 关键字。 在许多情况下你可以使用 java.util.concurrent 包中的一种机制，它会为你处理所有的加锁。
   - 如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。
   - 如果特别需要 Lock/Condition 结构提供的独有特性时，才使用 Lock/Condition。

### 5.6  同步阻塞

1. 每一个 Java 对象有一个锁。线程可以通过调用同步方法获得锁。还有另一种机制可以获得锁，通过进入一个同步阻塞。当线程进入如下形式的阻塞：

2. 当线程进入如下形式的阻塞：

   ```
   synchronized (obj) // this is the syntax for a synchronized block
   {
   	critical section
   }
   ```

   于是它获得 obj 的锁。在此， lock 对象被创建仅仅是用来使用每个 Java 对象持有的锁。

3. 有时程序员使用一个对象的锁来实现额外的原子操作， 实际上称为客户端锁定（client-side locking) 。客户端锁定是非常脆弱的，通常不推荐使用。

### 5.7  监视器概念

1. 锁和条件是线程同步的强大工具，但是，严格地讲， 它们不是面向对象的。

2. 在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性。最成功的解决方案之一是监视器 （monitor), 用 Java 的术语来讲， 监视器具有如下特性：

   - 监视器是只包含私有域的类。

   - 每个监视器类的对象有一个相关的锁。

   - 用该锁对所有的方法进行加锁。

     换句话说， 如果客户端调用 obj.method(), 那 么 obj对象的锁是在方法调用开始时自动获得， 并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时， 没有其他线程能访问该域。

   - 该锁可以有任意多个相关条件。

3.  Java 中的每一个对象有一个内部的锁和内部的条件。 如果一个方法用 synchronized 关键字声明，那么，它表现的就像是一个监视器方法。通过调用 wait/notifyAU/notify 来访问条件变量。

4. 然而， 在下述的 3 个方面 Java 对象不同于监视器， 从而使得线程的安全性下降：

   - 域不要求必须是 private。
   - 方法不要求必须是 synchronized。
   - 内部锁对客户是可用的。

### 5.8  Volatile 域

1. 使用现代的处理器与编译器， 出错的可能性很大。

   - 多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。
   - 编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义， 但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变！

   如果你使用锁来保护可以被多个线程访问的代码， 那么可以不考虑这种问题。 编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应， 并且不能不正当地重新排序指令。

2. volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。

   例如， 假定一个对象有一个布尔标记 done, 它的值被一个线程设置却被另一个线程査询， 如同我们讨论过的那样，你可以使用锁：

   ```java
   private boolean done;
   public synchronized boolean isDone() { return done; }
   public synchronized void setDone() { done = true; }
   //或许使用内部锁不是个好主意。如果另一个线程已经对该对象加锁， isDone 和 setDone方法可能阻塞。
   ```

   在这种情况下，将域声明为 volatile 是合理的：

   ```java
   private volatile boolean done;
   public boolean isDone() { return done; }
   public void setDone() { done = true; }
   ```

3. Volatile 变量不能提供原子性。

### 5.9  final 变置

1.  除非使用锁或 volatile 修饰符， 否则无法从多个线程安全地读取一个域。

2. 还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时。

   **final Map<String, Double〉accounts = new HashKap<>()；**

   其他线程会在构造函数完成构造之后才看到这个 accounts 变量。

3. 如果不使用 final，就不能保证其他线程看到的是 accounts 更新后的值，它们可能都只是看到 null, 而不是新构造的 HashMap。

4. 当然，对这个映射表的操作并不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步。

### 5.10  原子性

1. 假设对共享变量除了赋值之外并不完成其他操作， 那么可以将这些共享变量声明为volatile。

2. java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性。 例如， Atomiclnteger 类提供了方法 incrementAndGet 和decrementAndGet, 它们分别以原子方式将一个整数自增或自减。

   例如，可以安全地生成一个数值序列，如下所示：

   ```java
   public static AtomicLong nextNumber = new AtomicLong() ;
   // In some thread...
   long id = nextNumber.incrementAndGet();
   ```

   incrementAndGet 方法以原子方式将 AtomicLong 自增， 并返回自增后的值。也就是说，获得值、 增 1 并设置然后生成新值的操作不会中断。可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。

3. 有很多方法可以以原子方式设置和增减值， 不过， 如果希望完成更复杂的更新，就必须使用 compareAndSet 方法。 

   例如， 假设希望跟踪不同线程观察的最大值。下面的代码是不可行的：

   ```java
   public static AtonicLong largest = new AtomicLong()；
   // In some thread...
   largest.set(Math,max(largest.get(), observed)); // Error race condition!
   ```

   这个更新不是原子的。

   实际上，应当在一个循环中计算新值和使用 compareAndSet:

   ```java
   do {
   	oldValue = largest.get();
   	newValue = Math.max(oldValue, observed);
   } while (!largest.compareAndSet(oldValue, newValue));	
   ```

   如果另一个线程也在更新 largest，就可能阻止这个线程更新。这样一来，compareAndSet会返回 false, 而不会设置新值。在这种情况下， 循环会更次尝试，读取更新后的值，并尝试修改。 最终， 它会成功地用新值替换原来的值。这听上去有些麻烦， 不过 compareAndSet 方法会映射到一个处理器操作， 比使用锁速度更快。

4. 在 Java SE 8 中，不再需要编写这样的循环样板代码。实际上， 可以提供一个 lambda 表达式更新变量，它会为你完成更新。

   ```java
   largest.updateAndGet(x -> Math.max(x, observed)) ;
   //或
   largest.accumulateAndCet(observed, Math::max);
   ```

5. accumulateAndGet 方法利用一个二元操作符来合并原子值和所提供的参数。还有 getAndUpdate 和 getAndAccumulate 方法可以返回原值。

6. 如果有大量线程要访问相同的原子值， 性能会大幅下降， 因为乐观更新需要太多次重试。Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。

   - LongAdder 包括多个变量（加数)，其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。性能会有显著的提升。

   - 如果认为可能存在大量竞争， 只需要使用 LongAdder 而不是 AtomicLong。方法名稍有区别。调用 increment 让计数器自增，或者调用 add 来增加一个量， 或者调用 sum 来获取总和。

   - 当然， increment 方法不会返回原值。这样做会消除将求和分解到多个加数所带来的性能提升。

   - LongAccumulator 将这种思想推广到任意的累加操作。 在构造器中， 可以提供这个操作以及它的零元素。要加人新的值， 可以调用 accumulate。调用 get 来获得当前值。

     ```java
     LongAccumulator adder = new LongAccumulator(Long::sum, 0);
     // In some thread...
     adder.accumulate(value);
     ```

     在内部，这个累加器包含变量 a1, a2，…，an。每个变量初始化为零元素（这个例子中零元素为 0 )。

   - 调用 accumulate 并提供值 v 时，其中一 个变量会以原子方式更新为ai= ai op v, 这里 op是中缀形式的累加操作。get 的结果是 a1 opa2  op . . .op an.

   - 如果选择一个不同的操作，可以计算最小值或最大值。一般地， 这个操作必须满足结合律和交换律。这说明， 最终结果必须独立于所结合的中间值的顺序。

   - 另外 DoubleAdder 和 DoubleAccumulator 也采用同样的方式， 只不过处理的是 double 值。

### 5.11  死锁
