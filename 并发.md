# 并发

1. 并发执行的进程数目并不是由 CPU 数目制约的。操作系统将 CPU 的时间片分配给每一个进程， 给人并行处理的感觉。
2. 多线程程序在较低的层次上扩展了多任务的概念： 一个程序同时执行多个任务。通常，每一个任务称为一个线程（thread), 它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序（multithreaded)。
3. 多进程与多线程有哪些区别呢？ 本质的区别在于每个进程拥有自己的一整套变量， 而线程则共享数据。 
   - 共享变量使线程之间的通信比进程之间的通信更有效、 更容易。
   - 此外， 在有些操作系统中， 与进程相比较， 线程更“ 轻量级”， 创建、 撤销一个线程比启动新进程的开销要小得多。

## 1  什么是线程

1. 调用 Threadsleep 不会创建一个新线程，sleep 是 Thread 类的静态方法，用于暂停当前线程的活动。
2. sleep 方法可以抛出一个 IntermptedException 异常。

```java
import java.util.*;
import java.time.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.geom.*;

class Ball{
	private static final int XSIZE=15;
	private static final int YSIZE=15;
	private double x=0;
	private double y=0;
	private double dx=1;
	private double dy=1;

	public void move(Rectangle2D bounds){
		x+=dx;
		y+=dy;
		if (x<bounds.getMinX()) {
			x=bounds.getMinX();
			dx=-dx;
		}
		if (x+XSIZE>=bounds.getMaxX()) {
			x=bounds.getMaxX()-XSIZE;
			dx=-dx;
		}
		if (y<bounds.getMinY()) {
			y=bounds.getMinY();
			dy=-dy;
		}
		if (y+YSIZE>=bounds.getMaxY()) {
			y=bounds.getMaxY()-YSIZE;
			dy=-dy;
		}
	}
	public Ellipse2D getShape(){
		return new Ellipse2D.Double(x,y,XSIZE,YSIZE);
	}
}

class BallComponent extends JPanel{
	private static final int DEFAULT_WIDTH=600;
	private static final int DEFAULT_HEIGHT=600;

	private java.util.List<Ball> balls=new ArrayList<>();

	public void add(Ball b){
		balls.add(b);
	}

	public void paintComponent(Graphics g){
		super.paintComponent(g);
		Graphics2D g2=(Graphics2D) g;
		g2.setPaint(Color.BLUE);
		for (Ball b:balls){
			g2.fill(b.getShape());
		}
	}
	public Dimension getPreferredSize(){
		return new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT);
	}
}

class BounceFrame extends JFrame{
	private BallComponent comp;
	public static final int STEPS=1000;
	public static final int DELAY=3;

	public BounceFrame(){
		comp=new BallComponent();
		add(comp,BorderLayout.CENTER);
		JPanel buttonPanel=new JPanel();
		addButton(buttonPanel,"Start",event->addBall());
		addButton(buttonPanel,"Close",event->System.exit(0));
		add(buttonPanel,BorderLayout.SOUTH);
		pack();
	}

	public void addButton(Container c,String title,ActionListener listener){
		JButton button=new JButton(title);
		c.add(button);
		button.addActionListener(listener);
	}

	public void addBall(){
		try{
			Ball ball=new Ball();
			comp.add(ball);
			for (int i=1; i<=STEPS; i++) {
				ball.move(comp.getBounds());
				comp.paint(comp.getGraphics());
				Thread.sleep(DELAY);
			}
		}catch(InterruptedException e){
			e.printStackTrace();
		}
	}
}

public class TestBase9{
	public static void main(String[] args) {
		EventQueue.invokeLater(()->{
			JFrame frame=new BounceFrame();
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setTitle("弹球");  //设置框架标题
			frame.setLocation(300,300);
			frame.setVisible(true);  //使其可见性
		});
	}
}
```

### 1.1  使用线程给其他任务提供机会

1. 可以将移动球的代码放置在一个独立的线程中， 运行这段代码可以提高弹跳球的响应能力。实际上，可以发起多个球， 每个球都在自己的线程中运行。另外，AWT 的事件分派线程( event dispatch thread) 将一直地并行运行， 以处理用户界面的事件。由于每个线程都有机会得以运行，所以在球弹跳期间， 当用户点击 Close 按钮时， 事件调度线程将有机会关注到这个事件， 并处理“ 关闭” 这一动作。

```java
public void addBall(){
		Ball ball=new Ball();
		comp.add(ball);
		Runnable r=()->{
			try{
				for (int i=1; i<=STEPS; i++) {
					ball.move(comp.getBounds());
					comp.repaint();
					Thread.sleep(DELAY);
				}
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		};
		Thread t=new Thread(r);
		t.start();
	}
```
2. 在一个单独的线程中执行一个任务的简单过程：

   - 将任务代码移到实现了 Runnable 接口的类的 run 方法中。这个接口非常简单， 只有一个方法：

     public interface Runnable
     {
     	void run()；
     }

     由于 Runnable 是一个函数式接口，可以用 lambda 表达式建立一个实例：Runnable r = () -> { task code };

   - 由 Runnable 创建一个 Thread 对象： Thread t = new Thread(r);

   - 启动线程：t.start()；

3. 也可以通过构建一个 Thread 类的子类定义一个线程，

   ```
   class MyThread extends Thread
   {
       public void run()
       {
       task code
       }
   }
   ```

   然后， 构造一个子类的对象， 并调用 start 方法。 不过， 这种方法已不再推荐。 应该将要并行运行的任务与运行机制解耦合。如果有很多任务， 要为每个任务创建一个独立的线程所付出的代价太大了。 可以使用线程池来解决这个问题，

4. 不要调用 Thread 类或 Runnable 对象的 run 方法。 直接调用 run 方法， 只会执行同一个线程中的任务， 而不会启动新线程。 应该调用 Thread.start 方法。这个方法将创建一个执行 run 方法的新线程。

```java
java.lang.Thread
	Thread(Runnable target )  //构造一个新线程， 用于调用给定目标的 run() 方法。
	void start( )  //启动这个线程， 将引发调用 run() 方法。这个方法将立即返回， 并且新线程将并发运行。
	void run( )  //调用关联 Runnable 的 run 方法。
    void interrupt()  /*向线程发送中断请求。线程的中断状态将被设置为 true。如果目前该线程被一个 sleep调用阻塞，那么， InterruptedException 异常被抛出。*/
	static boolean interrupted()  /*测试当前线程（即正在执行这一命令的线程）是否被中断。注意，这是一个静态方法。	这一调用会产生副作用—它将当前线程的中断状态重置为 false。*/
	boolean isInterrupted()  //测试线程是否被终止。不像静态的中断方法，这一调用不改变线程的中断状态。
	static Thread currentThread()  //返回代表当前执行线程的 Thread 对象。
    void join( )  //等待终止指定的线程。
	void join(long mi11is)  //等待指定的线程死亡或者经过指定的毫秒数。
	Thread.State getState()  //得到这一线程的状态；NEW、RUNNABLE、BLOCKED、 WAITING、TIMED_WAITING或 TERMINATED 之一。
	void stop()  //停止该线程。这一方法已过时。
    void suspend()  //暂停这一线程的执行
	void resume()  //恢复线程。这一方法仅仅在调用 suspendO 之后调用。这一方法已过时。
    void setPriority(int newPriority)  //设置线程的优先级。
	static int MIN_PRIORITY  //线程的最小优先级。最小优先级的值为 1。
	static int N0RM_PRI0RITY  //线程的默认优先级。默认优先级为 5。
	static int MAX_PRIORITY  //线程的最高优先级。最高优先级的值为 10。
	static void yield( )  /*导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高
	的优先级，那么这些线程接下来会被调度。注意，这是一个静态方法。*/
    void setDaemon( boolean isDaemon )  //标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。

java.lang.Runnable
	void run( )  //必须覆盖这个方法， 并在这个方法中提供所要执行的任务指令。
```

## 2  中 断 线 程

1. 当线程的 run 方法执行方法体中最后一条语句后， 并经由执行 return 语句返冋时， 或者出现了在方法中没有捕获的异常时， 线程将终止。 

2. 没有可以强制线程终止的方法。然而， interrupt 方法可以用来请求终止线程。

3. 当对一个线程调用 interrupt 方法时，线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该不时地检査这个标志， 以判断线程是否被中断。

   要想弄清中断状态是否被置位， 首先调用静态的 Thread.currentThread 方法获得当前线程， 然后调用 islnterrupted 方法：

   ```java
   while (!Thread.currentThread().islnterrupted() && more work to do)
   {
   	do more work
   }
   ```

   但是， 如果线程被阻塞， 就无法检测中断状态。 这是产生 InterruptedExceptioii 异常的地方。

4. 当在一个被阻塞的线程 （调用 sleep 或 wait) 上调用 interrupt 方法时， 阻塞调用将会被Interrupted Exception 异常中断。（存在不能被中断的阻塞 I/O 调用， 应该考虑选择可中断的调用。)

5. 没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后， 继续执行， 而不理会中断。

6. 更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的 run 方法具有如下形式：

   ```java
   Runnable r = () -> {
   	try{
   		...;
   		while (!Thread.currentThread().islnterrupted0 && more work todo){
   			do more work
   		}
   	}catch(InterruptedException e){
   		// thread was interrupted during sleep or wait
   	}finally{
   		cleanup,if required
   	}
   	// exiting the run method terminates the thread
   };
   ```

   如果在每次工作迭代之后都调用 sleep 方法（或者其他的可中断方法 )， islnterrupted 检测 既没有必要也没有用处。 如果在中断状态被置位时调用 sleep 方法， 它不会休眠。 相反，它 将清除这一状态（!）并拋出 IntemiptedException。因此， 如果你的循环调用 sleep， 不会检 测中断状态。相反，要如下所示捕获 InterruptedException 异常：

   ```java
   Runnable r = () -> {
   	try{
   		...;
   		while (!Thread.currentThread().islnterrupted0 && more work todo){
   			do more work
   			Thread.sleep(delay);
   		}
   	}catch(InterruptedException e){
   		// thread was interrupted during sleep
   	}finally{
   		cleanup,if required
   	}
   	// exiting the run method terminates the thread
   };
   ```

7. Interrupted 方法是一个静态方法， 它检测当前的线程是否被中断。 而且， 调用 interrupted 方法会清除该线程的中断状态。 另一方面， islnterrupted 方法是一个实例方法， 可用来检验是否有线程被中断。调用这个方法不会改变中断状态。

8. 在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。

   ```java
   void mySubTask(){
   	...
   	try { sleep(delay); }
   	catch (InterruptedException e) { Thread.currentThread().interrupt(); }
   	...
   }
   ```

9. 或者， 更好的选择是， 用 throws InterruptedException 标记你的方法， 不采用 try 语句块捕获异常。于是， 调用者（或者， 最终的 run 方法）可以捕获这一异常。

   ```java
   void mySubTask() throws InterruptedException{
   	...
   	sleep(delay);
   	...
   }
   ```

   

## 3  线程状态

线程可以有如下 6 种状态：要确定一个线程的当前状态， 可调用 getState 方法。

- New (新创建）
- Runnable (可运行）
- Blocked ( 被阻塞）
- Waiting (等待）
- Timed waiting (计时等待）
- Terminated (被终止）

### 3.1  新创建线程

1. 当用 new 操作符创建一个新线程时， 如 newThread(r)， 该线程还没有开始运行。这意味着它的状态是 new。当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。

### 3.2  可运行线程

1. 一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线桿可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。（Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态。）
2. 一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。
3. 线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。 当时间片用完， 操作系统剥夺该线程的运行权， 并给另一个线程运行机会。当选择下一个线程时， 操作系统考虑线程的优先级。
4. 现在所有的桌面以及服务器操作系统都使用抢占式调度。但是， 像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 yield 方法、 或者被阻塞或等待时，线程才失去控制权。
5. 在具有多个处理器的机器上， 每一个处理器运行一个线程， 可以有多个线程并行运行。当然， 如果线程的数目多于处理器的数目， 调度器依然采用时间片机制。
6. 在任何给定时刻，二个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行)。

### 3.3  被阻塞线程和等待线程

1. 当线程处于被阻塞或等待状态时， 它暂时不活动。 它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。 细节取决于它是怎样达到非活动状态的。
   - 当一个线程试图获取一个内部的对象锁（而不是 javiutiUoncurrent 库中的锁)， 而该锁被其他线程持有， 则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
   - 当线程等待另一个线程通知调度器一个条件时， 它自己进入等待状态。在调用 Object.wait 方法或 Thread.join 方法， 或者是等待 java,util.concurrent 库中的 Lock 或 Condition 时， 就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。
   - 有几个方法有一个超时参数。调用它们导致线程进人计时等待（ timed waiting) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep 和 Object.wait、 Thread.join、 Lock,tryLock 以及 Condition.await 的计时版。

### 3.4  被终止的线程

1. 线程因如下两个原因之一而被终止：
   - 因为 run 方法正常退出而自然死亡。
   - 因为一个没有捕获的异常终止了 nm 方法而意外死亡。

线程状态

![线程状态](E:\pogject\javalearn\学习笔记\img\线程状态.png)

当一个线程被阻塞或等待时（或终止时)， 另一个线程被调度为运行状态。当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁)，调度器检查它是否具有比当前运行线程更高的优先级。 如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。

## 4  线 程 属 性

### 4.1  线程优先级

1. 在 Java 程序设计语言中， 每一个线程有一个优先级。 默认情况下， 一+线程继承它的父线程的优先级。 
2. 可以用 setPriority 方法提高或降低任何一个线程的优先级。可以将优先级设 置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的 任何值。NORM_PRIORITY 被定义为 5。
3. 每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。 当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多，也许更少。
4. 不要将程序构建为功能的正确性依赖于优先级。如果有几个高优先级的线程没有进入非活动状态， 低优先级的线程可能永远也不能执行。每当调度器决定运
   行一个新线程时， 首先会在具有高优先级的线程中进行选择， 尽管这样会使低优先级的线程完全饿死。

### 4.2  守护线程

1. 可以通过调用 **t.setDaemon(true)** ;将线程转换为守护线程（daemon thread)。
2. 守护线程的唯一用途是为其他线程提供服务。计时线程就是一个例子，它定时地发送“ 计时器嘀嗒” 信号给其他线程或清空过时的高速缓存项的线程。当只剩下守护线程时， 虚拟机就退出了， 由于如果只剩下守护线程， 就没必要继续运行程序了。
3. 守护线程应该永远不去访问固有资源， 如文件、 数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

### 4.3  未捕获异常处理器

1. 线程的 run 方法不能抛出任何受查异常， 但是，非受査异常会导致线程终止。在这种情况下，线程就死亡了。
2. 不需要任何 catch 子句来处理可以被传播的异常。 相反， 就在线程死亡之前， 异常被传递到一个用于未捕获异常的处理器。该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类。这个接口只有—个方法。 **void uncaughtException(Thread t, Throwable e)**
3. 可以用 setUncaughtExceptionHandler 方法为任何线程安装一个处理器。也可以用 Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有线程安装一个默认的处理器。 替换处理器可以使用日志 API 发送未捕获异常的报告到日志文件。
4. 如果不安装默认的处理器， 默认的处理器为空。 但是， 如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。
5. 线程组是一个可以统一管理的线程集合。默认情况下， 创建的所有线程属于相同的线程组， 但是， 也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。
6. ThreadGroup 类实现 Thread.UncaughtExceptionHandler 接口。 它的 uncaughtException 方法做如下操作：
   - 如果该线程组有父线程组， 那么父线程组的 uncaughtException 方法被调用。
   - 否则， 如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器， 则调用该处理器。
   - 否则， 如果 Throwable 是 ThreadDeath 的一个实例， 什么都不做。
   - 否则， 线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。（但是， 如果 e 是一个 ThreadDeath对象， 栈轨迹是被禁用的。)

```java
java.lang.Thread
	static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) 
	static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()
	//设置或获取未捕获异常的默认处理器。
	void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)
	Thread.UncaughtExceptionHandler getUncaughtExceptionHandler( )
	//设置或获取未捕获异常的处理器。 如果没有安装处理器， 则将线程组对象作为处理器。
java.lang.Thread.UncaughtExceptionHandler 
	void UncaughtException(Thread t, Throwable e)  //当一个线程因未捕获异常而终止， 按规定要将客户报告记录到日志中。

java.lang.ThreadGroup
	void UncaughtException(Thread t, Throwable e)  /**/
```



##  5  同 步

