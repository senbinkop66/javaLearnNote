# 图形程序设计

## 1  Swing 概述

1. 在 Java 1.0 刚刚出现的时候， 包含了一个用于基本 GUI 程序设计的类库，Sun 将它称为抽象窗口工具箱 （ Abstract Window Toolkit, AWT)。 基本 AWT 库采用将处理用户界面元素的任务委派给每个目标平台 （ Windows、Solaris、 Macintosh 等）的本地 GUI 工具箱的方式，由本地 GUI 工具箱负责用户界面元素的创建和动作。 
2. Swing 是不对等基于 GUI 工具箱的正式名字。它已是 Java 基础类库（Java FoundationClass, JFC) 的一部分。完整的 JFC 十分庞大， 其中包含的内容远远大于 Swing GUI 工具箱。JFC 特性不仅仅包含了 Swing 组件， 而且还包含了一个可访问性 API、一2D API 和一个可拖放 API。
3. Swing 没有完全替代 AWT , 而是基于 AWT 架构之上。Swing 仅仅提供了能力更加强大的用户界面组件。 尤其在采用 Swing 编写的程序中， 还需要使用基本的 AWT 处理事件。
4. 从现在开始，Swing 是指 “被绘制的” 用户界面类；AWT 是指像事件处理这样的窗口工具箱的底层机制。
5. 当然， 在用户屏幕上显示基于 Swing 用户界面的元素要比显示 AWT 的基于对等体组件的速度慢一些。鉴于以往的经验， 对于任何一台现代的计算机来说，微小的速度差别无妨大碍。
6. 由于下列几点无法抗拒的原因，人们选择 Swing:
   - Swing 拥有一个丰富、 便捷的用户界面元素集合。
   - Swing 对底层平台依赖的很少，因此与平台相关的 bug 很少。
   - Swing 给予不同平台的用户一致的感觉。
7.  Sun 开发了一种称为 Metal 的独立于平台的观感。 现在， 市场上人们将它称为“Java 观感”。
8. Java 7 提供了一个新观感， 称为 Nimbus , 不过默认情况下不可用。Nimbus使用了矢量绘图而不是位图绘图， 所以它不依赖于屏幕分辨率。
9. Java SE 5.0 引入了一种称为 Synth 的观感， 可以更容易地实现这一过程。 在 Synth中， 可以提供图像文件和 XML 描述文件来定义新的观感， 而无须进行任何编程。

##  2  创 建 框 架

1. 在 Java 中， 顶层窗口（就是没有包含在其他窗口中的窗口）被称为框架（frame)。

2. 在AWT 库中有一个称为 Frame 的类， 用于描述顶层窗口。 这个类的 Swing 版本名为 JFrame,它扩展于 Frame 类。JFrame 是极少数几个不绘制在画布上的 Swing 组件之一。因此，它的修饰部件（按钮、标题栏、 图标等）由用户的窗口系统绘制， 而不是由 Swing 绘制。

3.  绝大多数 Swing 组件类都以“J” 开头， 例如，JButton、JFrame 等。在 Java 中有Button 和 Frame 这样的类， 但它们属于 AWT 组件。如果偶然地忘记书写“
   J”， 程序仍然可以进行编译和运行，但是将 Swing 和 AWT 组件混合在一起使用将会导致视觉和行为的不一致。

   ```java
   import java.awt.*;
   import javax.swing.*;
   
   class SimpleFrame extends JFrame{
   	private static final int DEFAULT_WIDTH=300;
   	private static final int DEFAULT_HEIGHT=200;
   
   	public SimpleFrame(){
   		//构造器将框架大小设置为 300 x 200 像素。
   		setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
   	}
   
   }
   
   public class TestApplet1{
   	public static void main(String[] args) {
   		EventQueue.invokeLater(()->{
   			SimpleFrame frame=new SimpleFrame();  //构造一个 SimpleFrame 对象
   			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  //关闭这个框架时的响应动作
   			frame.setVisible(true);  //使其可见性
   			//frame.setUndecorated(true);  //关闭所有框架装饰
   		});
   	}
   }
   ```

4. Swing 类位于 javax.swing 包中。 包名 javax 表示这是一个 Java 扩展包， 而不是核心包。 出于历史原因 Swing类被认为是一个扩展。 不过从 1.2 版本开始， 在每个 JavaSE 实现中都包含它。

5. 在默认情况下， 框架的大小为 0 x 0 像素， 这种框架没有什么实际意义。这里定义了一个子类 SimpleFmme，它的构造器将框架大小设置为 300 x 200 像素。 这是SimpleFrame 和 JFrame 之间唯一的差别。

6. 在每个 Swing 程序中，有两个技术问题需要强调。

   - 首先， 所有的 Swing 组件必须由事件分派线程（event dispatch thread) 进行配置，线程将鼠标点击和按键控制转移到用户接口组件。
   - 接下来，定义一个用户关闭这个框架时的响应动作。对于这个程序而言， 只让程序简单地退出即可。

7. 许多 Swing 程序并没有在事件分派线程中初始化用户界面。 在主线程中完成初始化是通常采用的方式。

8. 在包含多个框架的程序中， 不能在用户关闭其中的一个框架时就让程序退出。在默认情况下，用户关闭窗口时只是将框架隐藏起来， 而程序并没有终止（在最后一个框架不可见之后，程序再终止，这样处理比较合适，而 Swing却不是这样工作的)。

9. 简单地构造框架是不会自动地显示出来的， 框架起初是不可见的。这就给程序员了一个机会， 可以在框架第一次显示之前往其中添加组件。为了显示框架，main方法需要调用框架的 setVisible 方法。

10. 在初始化语句结束后，main 方法退出。需要注意， 退出 main 并没有终止程序，终止的只是主线程。事件分派线程保持程序处于激活状态， 直到关闭框架或调用 SyStem.exit 方法终止程序。

11. 可以调用 frame.setUndecorated(true) 关闭所有框架装饰。

## 3  框架定位

Frame 类本身只包含若干个改变框架外观的方法。 当然，通过继承， 从 JFrame 的各个超类中继承了许多用于处理框架大小和位置的方法其中最重要的有下面几个：

- setLocation 和 setBounds 方法用于设置框架的位置。
- setlconlmage 用于告诉窗口系统在标题栏、任务切换窗口等位置显示哪个图标。
- setTitle 用于改变标题栏的文字。
- setResizable 利用一个 boolean 值确定框架的大小是否允许用户改变。

1. Component 类中的 setLocation 方法是重定位组件的一个方法。如果调用setLocation(x, y)则窗口将放置在左上角水平 x 像素，垂直 y 像素的位置， 坐标（0, 0 ) 位于屏幕的左上角。
2.  Component 中的 setBounds 方法可以实现一步重定位组件（特别是 JFrame) 大小和位置的操作， 例如：setBounds(x, y, width, height)
3. 可以让窗口系统控制窗口的位置， 如果在显示窗口之前调用**setLocationByPlatform(true)**。窗口系统会选用窗口的位置（而不是大小)，通常是距最后一个显示窗口很少偏移量的位置。
4. 对于框架来说， setLocation 和 setBounds 中的坐标均相对于整个屏幕。在容器中包含的组件所指的坐标均相对于容器。

### 3.1  框架属性

1. 组件类的很多方法是以获取 / 设置方法对形式出现的，这样的一个获取 / 设置方法对被称为一种属性。 属性包含属性名和类型。将 get 或 set 之后的第一个字母改为小写字母就可以得到相应的属性名。例如，Frame 类的下列方法：

   public String getTitle()
   public void setTitle(String title)

2. 从概念上讲，title 是框架的一个属性。当设置这个属性时， 希望这个标题能够改变用户屏幕上的显示。当获取这个属性时， 希望能够返回已经设置的属性值。

3. 如果类没有匹配的实例域， 我们将不清楚（也不关心）如何实现获取和设置方法。或许只是读、写实例域， 或许还执行了很多其他的操作。例如， 当标题发生变化时，通知给窗口系统。

4. 针对 get/set 约定有一个例外： 对于类型为 boolean 的属性， 获取方法由 is 开头。

   例如,下面两个方法定义了 locationByPlatform 属性：

   public boolean islocationByPIatfornO
   public void setLocationByPIatforra(boolean b)

   ```java
   		EventQueue.invokeLater(()->{
   			JFrame frame=new JFrame();
   			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
   			
   			Toolkit kit=Toolkit.getDefaultToolkit();
   			Dimension ScreenSize=kit.getScreenSize();  //以 Dimension 对象的形式返回屏幕的大小
   			int screenWidth=ScreenSize.width;
   			int screenHeight=ScreenSize.height;
   
   			frame.setSize(screenWidth/2,screenHeight/2);  //框架大小设定为屏幕大小的 50%，
   			frame.setLocationByPlatform(true);
   			frame.setTitle("框架测试");  //设置框架标题
   			Image img=new ImageIcon("./image/img2.jpg").getImage();  //使用工具箱加载图像
   			frame.setIconImage(img);  //将这个图像设置为框架的图标
   			//frame.setExtendedState(Frame.MAXIMIZED_BOTH);  //将程序的主框架尺寸设置为最大
   			frame.setVisible(true);  //使其可见性
   		});
   ```

### 3.2  确定合适的框架大小

1. 对于专业应用程序来说，应该检查屏幕的分辨率， 并根据其分辨率编写代码重置框架的大小， 

2. 为了得到屏幕的大小， 需要按照下列步骤操作。

   - 调用 Toolkit 类的静态方法 getDefaultToolkit 得到一个 Toolkit 对象（Toolkit 类包含很多与本地窗口系统打交道的方法)。
   - 然后，调用getScreenSize 方法， 这个方法以 Dimension 对象的形式返回屏幕的大小。Dimension 对象同时用公有实例变量 width 和 height 保存着屏幕的宽度和高度。
   - 将框架大小设定为上面取值的 50%，然后，告知窗口系统定位框架。

3. 另外， 还提供一个图标。由于图像的描述与系统有关， 所以需要再次使用工具箱加载图像。然后， 将这个图像设置为框架的图标。

4. 下面是为了处理框架给予的一些提示：

   - 如果框架中只包含标准的组件， 如按钮和文本框， 那么可以通过调用 pack 方法设置框架大小。框架将被设置为刚好能够放置所有组件的大小。在通常情况下， 将程序的主框架尺寸设置为最大。可以通过调用下列方法将框架设置为最大。

     **frame.setExtendedState(Frame.MAXIMIZEDJOTH):*;

   - 牢记用户定位应用程序的框架位置、 重置框架大小，并且在应用程序再次启动时恢复这些内容是一个不错的想法。

   - GraphicsDevice 类还允许以全屏模式执行应用。

```java
class SizedFrame extends JFrame{
	public SizedFrame(){
		Toolkit kit=Toolkit.getDefaultToolkit();
		Dimension ScreenSize=kit.getScreenSize();  //以 Dimension 对象的形式返回屏幕的大小
		int screenWidth=ScreenSize.width;
		int screenHeight=ScreenSize.height;
		setSize(screenWidth/2,screenHeight/2);
		setLocationByPlatform(true);
		Image img=new ImageIcon("./image/img2.jpg").getImage();
		setIconImage(img);
	}
}

public class TestApplet1{
	public static void main(String[] args) {
		EventQueue.invokeLater(()->{
			SizedFrame frame=new SizedFrame();
			frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
			frame.setTitle("自适应框架尺寸");  //设置框架标题
			frame.setVisible(true);  //使其可见性
		});
	}
}
```

```java
java.awt.Component
	boolean isVisible();
	void setVisible(boolean b)
	//获取或设置 visible 属性。 组件最初是可见的， 但 JFrame 这样的顶层组件例外。
	void setSize(int width,int heigth)
	//使用给定的宽度和高度， 重新设置组件的大小。
	void setLocation(int x,int y)
	//将组件移到一个新的位置上。 如果这个组件不是顶层组件， x 和 y 坐标 （或者 p.x 和p.y) 是容器坐标；否则是屏幕坐标
	void setBounds(int x,int y,int width,int heigth);
	//移动并重新设置组件的大小。
	Dimension getSize();
	void setSize()
	//获取或设置当前组件的 size 属性。

java.awt.Window 
	void toFront()  //将这个窗口显示在其他窗口前面。
	void toBack()  //将这个窗口移到桌面窗口栈的后面， 并相应地重新排列所有的可见窗口。
	boolean isLocationByPlatform()
	void setLocationByPlatform(boolean b)
	//获取或设置 locationByPlatform 属性。 这个属性在窗口显示之前被设置， 由平台选择一个合适的位置。

java.awt.Frame
	boolean isResizable()
	void setResizable(boolean b)
	//获取或设置 resizable 属性。这个属性设置后， 用户可以重新设置框架的大小。
	String getTitle()
	void setTitle(String s)
	//获取或设置 title 属性， 这个属性确定框架标题栏中的文字。
	Image getIconImage()
	void setIconImage(Image image)
	//获取或设置 iconlmage 属性， 这个属性确定框架的图标。窗口系统可能会将图标作为框架装饰或其他部位的一部分显示。
	boolean isUndecorated()
	void setUndecorated(boolean b)
	//获取或设置 undecorated 属性。这个属性设置后， 框架显示中将没有标题栏或关闭按钮这样的装饰。在框架显示之前， 必须调用这个方法。
	int getExtendedState()
	void setExpandedState(int state)
	//获取或设置窗口状态。状态是下列值之一。
		Frame.NORMAL
		Frame.ICONIFIED
		Frame.MAXIMIZED.HORIZ
		Frame.MAXIMIZED.VERT
		Frame.MAXIMIZEDJOTH

java.awt.Toolkit
	static Toolkit getDefaultToolkit()  //返回默认的工具箱。
	Dimension getScreenSize()  //返回用户屏幕的尺寸。

javax.swing.ImageIcon
	ImageIcon(String filename)  //构造一个图标， 其图像存储在一个文件中。
	Image getImage()  //获得该图标的图像。
```

## 4  在组件中显示信息

