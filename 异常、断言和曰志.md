# 异常、断言和曰志

## 1  处 理 错 误

### 1.0  错误处理

1. 如果由于出现错误而使得某些操作没有完成， 程序应该：

- 返回到一种安全状态，并能够让用户执行一些其他的命令； 或者
- 允许用户保存所有操作的结果，并以妥善的方式终止程序

2. 异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。为了能够在程序中处理异常情况， 必须研究程序中可能会出现的错误和问题， 以及哪类问题需要关注。
   - 用户输入错误
   - 设备错误
   - 物理限制
   - 代码错误
3. 异常具有自己的语法和特定的继承结构。

### 1.1  异常分类

1. 在 Java 程序设计语言中， 异常对象都是派生于 Throwable 类的一个实例。
2. 所有的异常都是由 Throwable 继承而来， 但在下一层立即分解为两个分支：Error 和 Exception。
   - Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。 应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。这种情况很少出现。
   - 在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是： 由程序错误导致的异常属于 RuntimeException ; 而程序本身没有问题， 但由于像 I/O 错误这类问题导致的异常属于其他异常: 
3. 派生于 RuntimeException 的异常包含下面几种情况：
   - 错误的类型转换。
   - 数组访问越界
   - 访问 null 指针
4. 不是派生于 RuntimeException 的异常包括：
   - 试图在文件尾部后面读取数据。
   - 试图打开一个不存在的文件。
   - 试图根据给定的字符串查找 Class 对象， 而这个字符串表示的类并不存在,
5. Java 语 言 规 范 将 派 生 于 Error 类 或 RuntimeException 类的所有异常称为非受查( unchecked) 异常， 所有其他的异常称为**受查（checked) 异常。**编译器将核查是否为所有的受査异常提供了异常处理器。
6. RuntimeException 这个名字很容易让人混淆。 实际上， 现在讨论的所有错误都发生在运行时。

### 1.2  声明受查异常

1. 一个方法不仅需要告诉编译器将要返回什么值， 还要告诉编译器有可能发生什么错误。

2. 方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受査异常。 

3. 在自己编写方法时， 不必将所有可能抛出的异常都进行声明。

4. 在遇到下面 4 种情况时应该抛出异常：

   - 调用一个抛出受査异常的方法， 例如， FilelnputStream 构造器。
   - 程序运行过程中发现错误， 并且利用 throw 语句抛出一个受查异常
   - 程序出现错误，
   - Java 虚拟机和运行时库出现的内部错误。

5. 对于那些可能被他人使用的 Java 方法， 应该根据异常规范（ exception specification), 在方法的首部声明这个方法可能抛出的异常。

6. 如果一个方法有可能抛出多个受查异常类型， 那么就必须在方法的首部列出所有的异常类。 每个异常类之间用逗号隔开。

   ```java
   public Image loadlmage(String s) throws FileNotFoundException, EOFException
   ```

7. 不需要声明 Java 的内部错误， 即从 Error 继承的错误。任何程序代码都具有抛出那些异常的潜能， 而我们对其没有任何控制能力。

8. 同样，也不应该声明从 RuntimeException 继承的那些非受查异常 .

9. 总之，一个方法必须声明所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生 （ RuntimeException)。 如果方法没有声明所有可能发生的受查异常， 编译器就会发出一个错误消息。

10. 如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用 （也就是说， 子类方法中可以抛出更特定的异常， 或者根本不抛出任何异常）。如果超类方法没有抛出任何受查异常， 子类也不能抛出任何受查异常。

11. 如果类中的一个方法声明将会抛出一个异常， 而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常， 或者这个类的任意一个子类的异常。

### 1.3  如何抛出异常

对于一个已经存在的异常类， 将其抛出非常容易 D 在这种情况下：

1. 找到一个合适的异常类。
2. 创建这个类的一个对象。
3. 将对象抛出。

一旦方法抛出了异常， 这个方法就不可能返回到调用者。也就是说， 不必为返回的默认值或错误代码担忧。

### 1.4  创建异常类

1. 习惯上， 定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器（超类 Throwable 的 toString 方法将会打印出这些详细信息， 这在调试中非常有用)。

```java
class FileFormatException extends IOException{
	public FileFormatException(){}
	public FileFormatException(String gripe){
		super(gripe);
	}
}

public class TestBase4{
	public String readData(BufferedReaderin) throws FileFormatException{

	}
	public static void main(String[] args){
		
	}
}
```

```java
javaJang.Throwabie
    Throwable( )
    构造一个新的 Throwabie 对象， 这个对象没有详细的描述信息。
    Throwable(String message)
    构造一个新的 throwable 对象， 这个对象带有特定的详细描述信息。习惯上， 所有派生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器。
     String getMessage()
    获得 Throwabie 对象的详细描述信息。
```

## 2  捕获异常

### 2.1  捕获异常

1. 如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息， 其中包括异常的类型和堆栈的内容。
2. 要想捕获一个异常， 必须设置 try/catch语句块。如果在 try语句块中的任何代码抛出了一个在 catch 子句中说明的异常类， 那么
   - 程序将跳过 try语句块的其余代码。
   - 程序将执行 catch 子句中的处理器代码。
3. 如果在 try 语句块中的代码没有拋出任何异常，那么程序将跳过 catch 子句。
4. 如果方法中的任何代码拋出了一个在 catch 子句中没有声明的异常类型，那么这个方法就会立刻退出

```java
	public void read(String filename){
		try{
			InputStream in=new FileInputStream(filename);
			int b;
			while ((b=in.read()!=-1)) {
                //读取并处理字节， 直到遇到文件结束符为止。
				System.out.println("process input");
			}
		}catch(IOException e){
            //生成一个栈轨迹
			e.printStackTrace();
		}
	}
```

