# 异常、断言和曰志

## 1  处 理 错 误

### 1.0  错误处理

1. 如果由于出现错误而使得某些操作没有完成， 程序应该：

- 返回到一种安全状态，并能够让用户执行一些其他的命令； 或者
- 允许用户保存所有操作的结果，并以妥善的方式终止程序

2. 异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。为了能够在程序中处理异常情况， 必须研究程序中可能会出现的错误和问题， 以及哪类问题需要关注。
   - 用户输入错误
   - 设备错误
   - 物理限制
   - 代码错误
3. 异常具有自己的语法和特定的继承结构。

### 1.1  异常分类

1. 在 Java 程序设计语言中， 异常对象都是派生于 Throwable 类的一个实例。
2. 所有的异常都是由 Throwable 继承而来， 但在下一层立即分解为两个分支：Error 和 Exception。
   - Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。 应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。这种情况很少出现。
   - 在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是： 由程序错误导致的异常属于 RuntimeException ; 而程序本身没有问题， 但由于像 I/O 错误这类问题导致的异常属于其他异常: 
3. 派生于 RuntimeException 的异常包含下面几种情况：
   - 错误的类型转换。
   - 数组访问越界
   - 访问 null 指针
4. 不是派生于 RuntimeException 的异常包括：
   - 试图在文件尾部后面读取数据。
   - 试图打开一个不存在的文件。
   - 试图根据给定的字符串查找 Class 对象， 而这个字符串表示的类并不存在,
5. Java 语 言 规 范 将 派 生 于 Error 类 或 RuntimeException 类的所有异常称为非受查( unchecked) 异常， 所有其他的异常称为**受查（checked) 异常。**编译器将核查是否为所有的受査异常提供了异常处理器。
6. RuntimeException 这个名字很容易让人混淆。 实际上， 现在讨论的所有错误都发生在运行时。

### 1.2  声明受查异常

1. 一个方法不仅需要告诉编译器将要返回什么值， 还要告诉编译器有可能发生什么错误。

2. 方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受査异常。 

3. 在自己编写方法时， 不必将所有可能抛出的异常都进行声明。

4. 在遇到下面 4 种情况时应该抛出异常：

   - 调用一个抛出受査异常的方法， 例如， FilelnputStream 构造器。
   - 程序运行过程中发现错误， 并且利用 throw 语句抛出一个受查异常
   - 程序出现错误，
   - Java 虚拟机和运行时库出现的内部错误。

5. 对于那些可能被他人使用的 Java 方法， 应该根据异常规范（ exception specification), 在方法的首部声明这个方法可能抛出的异常。

6. 如果一个方法有可能抛出多个受查异常类型， 那么就必须在方法的首部列出所有的异常类。 每个异常类之间用逗号隔开。

   ```java
   public Image loadlmage(String s) throws FileNotFoundException, EOFException
   ```

7. 不需要声明 Java 的内部错误， 即从 Error 继承的错误。任何程序代码都具有抛出那些异常的潜能， 而我们对其没有任何控制能力。

8. 同样，也不应该声明从 RuntimeException 继承的那些非受查异常 .

9. 总之，一个方法必须声明所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生 （ RuntimeException)。 如果方法没有声明所有可能发生的受查异常， 编译器就会发出一个错误消息。

10. 如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用 （也就是说， 子类方法中可以抛出更特定的异常， 或者根本不抛出任何异常）。如果超类方法没有抛出任何受查异常， 子类也不能抛出任何受查异常。

11. 如果类中的一个方法声明将会抛出一个异常， 而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常， 或者这个类的任意一个子类的异常。

### 1.3  如何抛出异常

对于一个已经存在的异常类， 将其抛出非常容易 D 在这种情况下：

1. 找到一个合适的异常类。
2. 创建这个类的一个对象。
3. 将对象抛出。

一旦方法抛出了异常， 这个方法就不可能返回到调用者。也就是说， 不必为返回的默认值或错误代码担忧。

### 1.4  创建异常类

1. 习惯上， 定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器（超类 Throwable 的 toString 方法将会打印出这些详细信息， 这在调试中非常有用)。

```java
class FileFormatException extends IOException{
	public FileFormatException(){}
	public FileFormatException(String gripe){
		super(gripe);
	}
}

public class TestBase4{
	public String readData(BufferedReaderin) throws FileFormatException{

	}
	public static void main(String[] args){
		
	}
}
```

```java
javaJang.Throwabie
    Throwable( )
    构造一个新的 Throwabie 对象， 这个对象没有详细的描述信息。
    Throwable(String message)
    构造一个新的 throwable 对象， 这个对象带有特定的详细描述信息。习惯上， 所有派生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器。
     String getMessage()
    获得 Throwabie 对象的详细描述信息。
```

## 2  捕获异常

### 2.1  捕获异常

1. 如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息， 其中包括异常的类型和堆栈的内容。
2. 要想捕获一个异常， 必须设置 try/catch语句块。如果在 try语句块中的任何代码抛出了一个在 catch 子句中说明的异常类， 那么
   - 程序将跳过 try语句块的其余代码。
   - 程序将执行 catch 子句中的处理器代码。
3. 如果在 try 语句块中的代码没有拋出任何异常，那么程序将跳过 catch 子句。
4. 如果方法中的任何代码拋出了一个在 catch 子句中没有声明的异常类型，那么这个方法就会立刻退出（希望调用者为这种类型的异常设计了catch 子句)。

```java
	public void read(String filename){
		try{
			InputStream in=new FileInputStream(filename);
			int b;
			while ((b=in.read()!=-1)) {
                //读取并处理字节， 直到遇到文件结束符为止。
				System.out.println("process input");
			}
		}catch(IOException e){
            //生成一个栈轨迹
			e.printStackTrace();
		}
	}
```

通常， 最好的选择是什么也不做，而是将异常传递给调用者。如果采用这种处理方式，就必须声明这个方法可能会拋出一个IOException。

```java
	public void read(String filename) throws IOException{
		InputStream in=new FileInputStream(filename);
		int b;
		while ((b=in.read()!=-1)) {
			System.out.println("process input");
		}
	}
```

通常， 应该捕获那些知道如何处理的异常， 而将那些不知道怎样处理的异常继续进行传递。

如果想传递一个异常， 就必须在方法的首部添加一个 throws 说明符， 以便告知调用者这个方法可能会抛出异常。

### 2.2  捕获多个异常

1. 在一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。

   ```java
   try{
   	//code that might throw exceptions
   }catch (FileNotFoundException e){
   	//emergencyactionfor missingfiles
   }catch (UnknownHostException e){
   	//emergencyactionfor unknown hosts
   }catch (IOException e){
   	//emergencyactionfor all other I/O problems
   }
   ```

2. 异常对象可能包含与异常本身有关的信息。要想获得对象的更多信息， 可以试着使用**e.getHessage()**得到详细的错误信息（如果有的话)，或者使用**e.getClass().getName()**得到异常对象的实际类型。

3. 在 Java SE 7 中，同一个 catch 子句中可以捕获多个异常类型。只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。

   ```java
   try{
   	//code that might throw exceptions
   }catch (FileNotFoundException | UnknownHostException e){
   	//emergencyactionfor missingfiles and unknown hosts
   }catch (IOException e){
   	//emergencyactionfor all other I/O problems
   }
   ```

4. 捕获多个异常时， 异常变量隐含为 final 变量。

5. 捕获多个异常不仅会让你的代码看起来更简单， 还会更高效。 生成的字节码只包含一个对应公共 catch 子句的代码块。

### 2.3  再次抛出异常与异常链

1. 在 catch 子句中可以抛出一个异常， 这样做的目的是改变异常的类型，

   ```java
   try{
   	//access the database
   }catch (SQLException e){
   	Throwable se = new ServletException("database error")；
   	se.initCause(e);
   	throw se;
   }
   //当捕获到异常时， 就可以使用下面这条语句重新得到原始异常：
   Throwable e = se.getCauseO;
   ```

2. 如果在一个方法中发生了一个受查异常， 而不允许抛出它， 那么包装技术就十分有用。我们可以捕获这个受查异常， 并将它包装成一个运行时异常。

3. 有时你可能只想记录一个异常， 再将它重新抛出， 而不做任何改变。

   ```java
   try{
   	//access the database
   }catch (Exception e){
   	logger.log(level, message, e);
   	throw e;
   }
   ```

### 2.4  finally 子句

```java
try{
    //1
	//code that might throw exceptions
    //2
}catch (Exception e){
	//3
    //show error message
    //4
}finally{
	//5
}
//6
```

不管是否有异常被捕获， finally 子句中的代码都被执行。 有下列 3 种情况会执行 finally 子句：

1. 代码没有抛出异常。 在这种情况下， 程序首先执行 try 语句块中的全部代码， 然后执行 finally 子句中的代码。随后， 继续执行 try 语句块之后的第一条语句。执行标注的 1、 2、 5、 6 处。
2. 抛出一个在 catch 子句中捕获的异常。在这种情况下，程序将执行 try 语句块中的所有代码，直到发生异常为止。此时，将跳过 try 语句块中的剩余代码， 转去执行与该异常匹配的 catch 子句中的代码， 最后执行 finally 子句中的代码。
   - 如果 catch 子句没有抛出异常， 程序将执行 try 语句块之后的第一条语句。执行标注 1、 3、 4、5、 6 处的语句。
   - 如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。执行标注1、 3、 5 处的语句。
3. 代码抛出了一个异常， 但这个异常不是由 catch 子句捕获的。在这种情况下， 程序将执行 try 语句块中的所有语句，直到有异常被抛出为止。此时， 将跳过 try 语句块中的剩余代码， 然后执行 finally 子句中的语句， 并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。

try 语句可以只有 finally 子句， 而没有 catch 子句。

```java
try{
	//code that might throw exceptions
}finally{
	//
}
```

无论在 try 语句块中是否遇到异常， finally 子句中的语句都会被执行。当然,如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 catch 子句捕获。 我们认为在需要关闭资源时， 用这种方式使用 finally 子句是一种不错的选择。

强烈建议解搞合 try/catch 和 try/finally 语句块。 这样可以提高代码的清晰度。这种设计方式不仅清楚， 而且还具有一个功能， 就是将会报告 finally 子句中出现的错误。

```java
InputStream in=new FileInputStream(filename);
try{
	try{
		//内层的 try 语句块只有一个职责， 就是确保关闭输入流。
	//code that might throw exceptions
	}finally{
		//in.closeO;
	}
}catch (IOException e){
	// 外层的 try 语句块也只有一个职责， 就是确保报告出现的错误。
	//show error message
}
```

当 finally 子句包含 return 语句时， 将会出现一种意想不到的结果„ 假设利用 return语句从 try语句块中退出。在方法返回前， finally 子句的内容将被执行。 如果 finally 子句中也有一个 return 语句， 这个返回值将会覆盖原始的返回值。

```java
public static int f(int n){
	try{
		int r=n+n*n;
		return r;
	}finally{
		if (n==5) {
			return 0;
		}
	}
}
```

有时候， finally 子句也会带来麻烦。 例如， 清理资源的方法也有可能抛出异常。

### 2.5  带资源的 try 语句

1. 带资源的 try 语句（try-with-resources) 的最简形式为：

   ```java
   try (Resource res=...){
   	//work with res
   }
   //try 块退出时，会自动调用 res.dose()。
   ```

   ```java
   	try (Scanner in=new Scanner(new FileInputStream("./test.txt"))){
   		while (in.hasNext()) {
   			System.out.println(in.next());
   		}
   	}
   //这个块正常退出时， 或者存在一个异常时， 都会调用 in.close()方法， 就好像使用了finally块一样。
   ```

2. 带资源的 try 语句可以很好地处理这种情况。原来的异常会重新抛出，而 close方法抛出的异常会“ 被抑制。 这些异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。 如果对这些异常感兴趣， 可以调用 getSuppressed 方法， 它会得到从 close 方法抛出并被抑制的异常列表。

3. 带资源的 try 语句自身也可以有 catch 子 句 和 一 个 finally 子句。 这 些 子 句 会 在关闭资源之后执行。 不过在实际中， 一 个 try 语句中加入这么多内容可能不是一个好主 意。

### 2.6  分析堆栈轨迹元素

1. 堆栈轨迹（ stack trace ) 是一个方法调用过程的列表， 它包含了程序执行过程中方法调用的特定位置前面已经看到过这种列表， 当 Java 程序正常终止， 而没有捕获异常时， 这个列表就会显示出来。

2. 可以调用 Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述信息

   ```java
   Throwable t = new Throwable()；
   StringWriter out = new StringWriter();
   t.printStackTrace(new PrintWriter(out));
   String description = out.toString();
   ```

3. 一种更灵活的方法是使用 getStackTrace 方法， 它会得到 StackTraceElement 对象的一个数组， 可以在你的程序中分析这个对象数组。

   ```java
   Throwable t = new Throwable();
   StackTraceElement[] frames = t.getStackTrace();
   for (StackTraceElement frame : frames)
   	analyze frame
   ```

   StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法， 同时， 还含有能够获得类名和方法名的方法。toString 方法将产生一个格式化的字符串， 其屮包含所获得的信息。

4. 静态的 Thread.getAllStackTrace 方法， 它可以产生所有线程的堆栈轨迹

   ```
   Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
   for (Thread t : map.keySet ())
   {
       StackTraceElement[] frames = map.get(t);
       analyze frames
   }
   ```

   ```java
   import java.util.*;
   import java.io.*;
   
   public class TestBase4{
   	//打印了递归阶乘函数的堆栈情况。
   	public static int factorial(int n){
   		System.out.println("factorial("+n+"):");
   		Throwable t=new Throwable();
   		StackTraceElement[] frames=t.getStackTrace();
   		for (StackTraceElement f:frames) {
   			System.out.println(f);
   		}
   		System.out.println();
   		int r;
   		if (n<1) r=1;
   		else r=n*factorial(n-1);
   		System.out.println("return "+r);
   		return r;
   	}
   	public static void main(String[] args){
   		factorial(3);
   	}
   }
   /*
   Compiling TestBase4.java......
   ------Output------
   factorial(3):
   TestBase4.factorial(TestBase4.java:8)
   TestBase4.main(TestBase4.java:21)
   
   factorial(2):
   TestBase4.factorial(TestBase4.java:8)
   TestBase4.factorial(TestBase4.java:16)
   TestBase4.main(TestBase4.java:21)
   
   factorial(1):
   TestBase4.factorial(TestBase4.java:8)
   TestBase4.factorial(TestBase4.java:16)
   TestBase4.factorial(TestBase4.java:16)
   TestBase4.main(TestBase4.java:21)
   
   factorial(0):
   TestBase4.factorial(TestBase4.java:8)
   TestBase4.factorial(TestBase4.java:16)
   TestBase4.factorial(TestBase4.java:16)
   TestBase4.factorial(TestBase4.java:16)
   TestBase4.main(TestBase4.java:21)
   
   return 1
   return 1
   return 2
   return 6
   [Finished in 1.2s]
   */
   ```

   

## 3  使用异常机制的技巧

1. 异常处理不能代替简单的测试。

   与执行简单的测试相比， 捕获异常所花费的时间大大超过了前者， 因此使用异常的基本规则是：只在异常情况下使用异常机制。

2. 不要过分地细化异常

3. 利用异常层次结构

   - 不要只抛出 RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。
   - 不要只捕获 Thowable 异常， 否则，会使程序代码更难读、 更难维护。
   - 考虑受查异常与非受查异常的区别。 已检查异常本来就很庞大，不要为逻辑错误抛出这些异常。
   - 将一种异常转换成另一种更加适合的异常时不要犹豫。

4. 不要压制异常。如果认为异常非常重要， 就应该对它们进行处理。

5. 在检测错误时，“ 苛刻” 要比放任更好

   在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一个 NullPointerException 异常更好。

6. 不要羞于传递异常。

   让高层次的方法通知用户发生了错误， 或者放弃不成功的命令更加适宜。 早抛出， 晚捕获。

## 4  使用断言

