# 继承

## 1  类、超类和子类

### 1.1  定义子类

1. Java 与 C++ 定义继承类的方式十分相似。 Java 用关键字 extends 代替了 C++中的冒号（：）。 在 Java 中， 所有的继承都是公有继承， 而没有 C++ 中的私有继承和保护继承。

2. 关键字 extends 表明正在构造的新类派生于一个已存在的类。 已存在的类称为超类( superclass )、 基类（ base class) 或父类（parent class); 

3. 新类称为子类（subclass)、 派生类(derived class) 或孩子类（child class)。超类和子类是 Java 程序员最常用的两个术语， 而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这些都是继承时使用的术语。

4. 超类并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反，子类比超类拥有的功能更加丰富。

5. 前缀“ 超” 和“ 子” 来源于计算机科学和数学理论中的集合语言的术语。所有雇员组成的集合包含所有经理组成的集合。 可以这样说， 雇员集合是经理集合的超集， 也可以说， 经理集合是雇员集合的子集。

6. 在通过扩展超类定义子类的时候， 仅需要指出子类与超类的不同之处。 因此在设计类的时候，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中，这种将通用的功能放到超类的做法，在面向对象程序设计中十分普遍。

   ```java
   class Manager extends Employee{
   	//新增属性
   	private double bonus;
   
   	//新增方法
   	public void setBonus(double bonus){
   		this.bonus=bonus;
   	}
   }
   ```

### 1.2  覆盖方法

1. super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编译器调用超类方法的特殊关键字。

2. 在子类中可以增加域、 增加方法或覆盖超类的方法， 然而绝对不能删除继承的任何域和方法。

3. 在 Java 中使用关键字 super 调用超类的方法。super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。

4. 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 public, 子类方法一定要声明为 public。

   经常会发生这类错误：在声明子类方法的时候， 遗漏了 public 修饰符。此时， 编译器将会把它解释为试图提供更严格的访问权限。
   ```java
   	//覆盖方法
   	public double getSalary(){
   		//调用超类 Employee 中的 getSalary 方法
   		double baseSalary=super.getSalary();
   		return baseSalary+bonus;
   	}
   ```

### 1.3  子类构造器

1. 由于 Manager 类的构造器不能访问 Employee 类的私有域， 所以必须利用 Employee 类的构造器对这部分私有域进行初始化， 我们可以通过 super 实现对超类构造器的调用。使用super 调用构造器的语句必须是子类构造器的第一条语句。

2. 如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。 

3. 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器’ 则 Java 编译器将报告错误。

4. 构造参数既可以传递给本类 （ this) 的其他构造器， 也可以传递给超类（super ) 的构造器。

   ```java
   	//子类构造器
   	public Manager(String n,double s,int y,int m,int d){
   		super(n,s,y,m,d);
   		bonus=0;
   	}
   ```

   1. 一个对象变量（例如， 变量 e) 可以指示多种实际类型的现象被称为多态（polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（ dynamic binding)。虚拟机知道e 实际引用的对象类型， 因此能够正确地调用相应的方法。
   2. 在 Java 中， 不需要将方法声明为虚拟方法。 动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征， 可以将它标记为 final 

```java
		Employee[] staff=new Employee[4];

		staff[0]=new Employee("mane",20,2015,6,11);
		staff[1]=new Employee("Alison",23,2018,6,26);
		staff[2]=new Employee("Arnold",18,2006,6,6);
		Manager boss=new Manager("kloop",50,2015,10,10);
		boss.setBonus(1000);
		staff[3]=boss;
		
		for (Employee e:staff){
			e.raiseSalary(5);
		}

		for (Employee e:staff){
			System.out.println("name:"+e.getName()+",salary:"+e.getSalary()+",hireDay:"+e.getHireDay());
		}

```

### 1.4  继承层次

1. 继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次（ inheritance hierarchy )。在继承层次中， 从某个特定的类到其祖先的路径被称为该类的继承链 ( inheritance chain) 。
2. 通常， 一个祖先类可以拥有多个子孙继承链。
3. Java 不支持多继承。

### 1.5  多 态

1. 有一个用来判断是否应该设计为继承关系的简单规则， 这就是“ is-a” 规则， 它表明子类的每个对象也是超类的对象。

2. “is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。可以将一个子类的对象赋给超类变量。

   ```java
   Employee e;
   e = new Employee(. . .);
   // Employee object expected
   e = new Manager(. . .); // OK, Manager can be used as well
   ```

   

3. 在 Java 程序设计语言中， 对象变量是多态的。 一个 Employee 变量既可以引用一个Employee 类对象， 也可以引用一个 Employee 类的任何一个子类的对象（例如， Manager、Executive、Secretary 等）。

   ```java
   //可以这样调用
   boss.setBonus(5000); // OK
   //但不能这样调用
   staff[0].setBonus(5000); // Error
   ```

4. 不能将一个超类的引用赋给子类变量。

   ```java
   Manager m = staff[i]; // Error
   ```

5. 在 Java 中， 子类数组的引用可以转换成超类数组的引用， 而不需要采用强制类型转换。

   ```java
   Manager[] managers = new Manager[10];
   //将它转换成 Employee[] 数组完全是合法的：
   Employee[] staff = managers; // OK
   ```

   为了确保不发生这类错误， 所有数组都要牢记创建它们的元素类型， 并负责监督仅将类型兼容的引用存储到数组中。例如， 使用 new managers[10] 创建的数组是一个经理数组。如果试图存储一个 Employee 类型的引用就会引发 ArrayStoreException 异常。

### 1.6  理解方法调用

下面假设要调用 x.f(args)， 隐式参数 x 声明为类 C 的一个对象。下面是调用过程的详细描述：

1. 编译器査看对象的声明类型和方法名。

   假设调用 x.f(param)，且隐式参数 x 声明为 C类的对象。需要注意的是： 有可能存在多个名字为 f, 但参数类型不一样的方法。例如， 可能存在方法 f(im) 和方法 String)。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法 （超类的私有方法不可访问）。

   至此， 编译器已获得所有可能被调用的候选方法。

2. 接下来，编译器将査看调用方法时提供的参数类型。

   如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配， 就选择这个方法。这个过程被称为**重栽解析** （ overloading resolution)。 例如， 对于调用 x.f(“Hello” ）来说， 编译器将会挑选 f(String)， 而不是 f(int)。由于允许类型转换（ int 可以转换成 double, Manager 可以转换成 Employee, 等等)， 所以这个过程可能很复杂。

   如果编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后有多个方法与之匹配， 就会报告一个错误。

   至此， 编译器已获得需要调用的方法名字和参数类型。

3. 如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding)。

    与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。 在我们列举的示例中， 编译器采用动态绑定的方式生成一条调用 f(String) 的指令。

4. 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。

   假设 x 的实际类型是 D，它是 C 类的子类。 如果 D 类定义了方法 f(String)，就直接调用它；否则， 将在 D 类的超类中寻找 f(String)， 以此类推。

   - 每次调用方法都要进行搜索，时间开销相当大。因此， 虚拟机预先为每个类创建了一个方法表（ method table), 其中列出了所有方法的签名和实际调用的方法。
   - 这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。在前面的例子中， 虚拟机搜索 D 类的方法表， 以便寻找与调用 f(Sting) 相K配的方法。这个方法既有可能是 D.f(String), 也有可能是X.f(String), 这里的 X 是 D 的超类。这里需要提醒一点， 如果调用 super.f(param), 编译器将对隐式参数超类的方法表进行搜索。
   - 动态绑定有一个非常重要的特性： 无需对现存的代码进行修改，就可以对程序进行扩展。
     假设增加一个新类 Executive, 并且变量 e 有可能引用这个类的对象， 我们不需要对包含调用e.getSalary() 的代码进行重新编译。 如果 e 恰好引用一个 Executive 类的对象， 就会自动地调用 Executive.getSalaryO 方法。


### 1.7  阻止继承：final 类和方法

1. 不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。 例如， 假设希望阻止人们定义Executive 类的子类，就可以在定义这个类的时候’使用 final 修饰符声明。

2. 类中的特定方法也可以被声明为 final。 如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法 )。

   ```java
   	public final String getDepartment(){
   		return "Manager";
   	}
   }
   
   public final class Executive extends Manager{
   
   }
   ```

3.  对于 final 域来说， 构造对象之后就不允许改变它们的值了。 不过， 如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。

4. 将方法或类声明为 final 主要目的是： **确保它们不会在子类中改变语义**。

5. 如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为**内联( inlining)**。 例如，内联调用 e.getName( ) 将被替换为访问 e.name 域。这是一项很有意义的改进， 这是由于 CPU 在处理调用方法的指令时， 使用的分支转移会扰乱预取指令的策略， 所以，这被视为不受欢迎的。然而， 如果 getName 在另外一个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作， 因此也就不能对它进行内联处理了。

6.  虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系， 并能够检测出类中是否真正地存在覆盖给定的方法。 

### 1.8  强制类型转换

1. 将一个类型强制转换成另外一个类型的过程被称为类型转换。Java 程序设计语言提供了一种专门用于进行类型转换的表示法。

   ```java
   double x = 3.405;
   int nx = (int) x;
   //将表达式 x 的值转换成整数类型， 舍弃了小数部分
   ```

2. 正像有时候需要将浮点型数值转换成整型数值一样， 有时候也可能需要将某个类的对象引用转换成另外一个类的对象引用。

3. 对象引用的转换语法与数值表达式的类型转换类似， 仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。

   ```java
   Manager boss = (Manager) staff[0]:
   ```

4. 进行类型转换的唯一原因是：**在暂时忽视对象的实际类型之后， 使用对象的全部功能**。

5. 在 Java 中， 每个对象变量都属于一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。例如，staff[i] 引用一个 Employee 对象（因此它还可以引用 Manager对象 )。

6. 将一个值存人变量时， 编译器将检查是否允许该操作。将一个了-类的引用赋给一个超类变量， 编译器是允许的。但将一个超类的引用赋给一个子类变量， 必须进行类型转换， 这样才能够通过运行时的检査。

7. 在进行类型转换之前， 先查看一下是否能够成功地转换。这个过程简单地使用instanceof 操作符就可以实现。 如果这个类型转换不可能成功， 编译器就不会进行这个转换。

   ```java
   //Manager boss = (Manager) staff[1]; // Error
   if (staff[1] instanceof Manager)
   {
   	Manager boss = (Manager) staff[1];
   }
   String c = (String) staff[1]; //将会产生编译错误， 这是因为 String 不是 Employee 的子类。
   ```

8. 只能在继承层次内进行类型转换。在将超类转换成子类之前，应该使用 instanceof 进行检查。

9. 实际上，通过类型转换调整对象的类型并不是一种好的做法。 在一般情况下，应该尽量少用类型转换和 instanceof 运算符。

### 1.9  抽象类

1. 如果自下而上在类的继承层次结构中上移， 位于上层的类更具有通用性，甚至可能更加抽象。 从某种角度看， 祖先类更加通用， 人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。

   例如， 考虑一下对 Employee 类层次的扩展。一名雇员是一个人， 一名学生也是一个人。下面将类 Person 和类 Student 添加到类的层次结构中。

2. 包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外， 抽象类还可以包含具体数据和具体方法。

3. 抽象方法充当着占位的角色， 它们的具体实现在子类中。

4. 扩展抽象类可以有两种选择。一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。

5. 类即使不含抽象方法，也可以将类声明为抽象类。

6. 抽象类不能被实例化。也就是说， 如果将一个类声明为 abstract, 就不能创建这个类的对象。

7. 可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象。

   ```java
   Person p = new Student("mane" , "forward");
   ```

   ```java
   package abstractClasses;
   
   public class TestAbstract{
   	public static void main(String[] args) {
   		Person[] people=new Person[2];
   
   		people[0]=new Employee("bob",200000,2015,7,1);
   		people[1]=new Student("mike","defender");
   
   		for (Person p:people){
   			System.out.println(p.getName()+", "+p.getDescription());
   		}
   	}
   }
   ```
   
### 1.10  受保护访问

1. 有时候，希望超类中的某些方法允许被子类访问， 或允许子类的方法访问超类的某个域。 为此， 需要将这些方法或域声明为 protected。 
2.  如果需要限制某个方法的使用， 就可以将它声明为protected。 这表明子类（可能很熟悉祖先类）得到信任， 可以正确地使用这个方法， 而其他类则不行。
3. 事实上，Java 中的受保护部分对所有子类及同一个包中的所有其他类都可见。

## 2  Object： 所有类的超类

1. Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的。

2. 如果没有明确地指出超类，Object 就被认为是这个类的超类。

3. 可以使用 Object 类型的变量引用任何类型的对象：

   ```java
   Object obj = new EmployeeC'Harry Hacker", 35000) ;
   ```

   当然， Object 类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作， 还需要清楚对象的原始类型， 并进行相应的类型转换：

   ```java
   Employee e = (Employee) obj ;
   ```

4. 在 Java 中， 只有基本类型 （ primitive types) 不是对象， 例如， 数值、 字符和布尔类型的值都不是对象。所有的数组类塱，不管是对象数组还是基本类型的数组都扩展了 Object 类。

```java
   Employee[] staff = new Employee[10];
   obj = staff; // OK
   obj = new int[10]; // OK
```

###    2.1  equals 方法

1. Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中， 这个方法将判断两个对象是否具有相同的引用。 如果两个对象具有相同的引用， 它们一定是相等的。

2. 然而， 经常需要检测两个对象状态的相等性， 如果两个对象的状态相等， 就认为这两个对象是相等的。

   
```java
	public boolean equals(Object otherObject){
		if (this==otherObject) {
			return true;
		}
		if (otherObject==null) {
			return false;
		}
		if (getClass()!=otherObject.getClass()) {
			return false;
		}
		Employee otherObject=(Employee) otherObject;
		return otherObjectect.equals(name,otherObject.name) && 
		salary==otherObject.salary && otherObjectect.equals(hireDay,otherObject.hireDay);
	}
```

3. 在子类中定义 equals 方法时， 首先调用超类的 equals。 如果检测失败， 对象就不可能相等。 如果超类中的域都相等， 就需要比较子类中的实例域。


```java
	public boolean equals(Object otherObject){
		if (!super.equals(otherObject)) {
			return false;
		}
		Manager otherObject=(Manager) otherObject;
		return bonus==otherObject.bonus;
	}
```

### 2.2  相等测试与继承

Java 语言规范要求 equals 方法具有下面的特性：

1. 自反性： 对于任何非空引用 x, x.equals(x) 应该返回 true。
2. 对称性: 对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true, x.equals(y) 也应该返回 true。
   - 如果子类能够拥有自己的相等概念， 则对称性需求将强制采用 getClass 进行检测
   - 如果由超类决定相等的概念，那么就可以使用 imtanceof 进行检测， 这样可以在不同子类的对象之间进行相等的比较。
3. 传递性： 对于任何引用 x、 y 和 z, 如果 x.equals(y) 返 N true， y.equals(z) 返回 true,x.equals(z) 也应该返回 true。
4. 一致性： 如果 x 和 y 引用的对象没有发生变化， 反复调用 x.eqimIS(y) 应该返回同样的结果。
5. 对于任意非空引用 x, x.equals(null) 应该返回 false。

编写一个完美的 equals 方法的建议：

1. 显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。

2. 检测 this 与 otherObject 是否引用同一个对象：

   ```java
   if (this = otherObject) return true;
   //计算这个等式要比一个一个地比较类中的域所付出的代价小得多。
   ```

3. 检测 otherObject 是否为 null, 如 果 为 null, 返 回 false。这项检测是很必要的。

   ```java
   if (otherObject = null) return false;
   ```

4. 比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：

   ```java
   if (getClass() != otherObject.getCIassO) return false;
   //如果所有的子类都拥有统一的语义，就使用 instanceof 检测：
   if (!(otherObject instanceof ClassName)) return false;
   ```

5. 将 otherObject 转换为相应的类类型变量：

   ```java
   ClassName other = (ClassName) otherObject
   ```

6. 现在开始对所有需要比较的域进行比较了。使用= 比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配， 就返回 true; 否 则 返 回 false。如果在子类中重新定义 equals, 就要在其中包含调用 super.equals(other)。

   ```java
   return fieldl == other.field && Objects.equa1s(fie1d2, other.field2) && ...;
   ```

7. 对于数组类型的域， 可以使用静态的 Arrays.equals 方法检测相应的数组元素是否相等。

   ```java
    java.util.Arrays 
    static Boolean equals(type[] a , type[] b) 5.0
   如果两个数组长度相同， 并且在对应的位置上数据元素也均相同， 将返回 true。 数组的元素类型可以是 Object、 int、 long、 short、 char、 byte、 boolean、 float 或 double。
   
   java.util.Objects 
   static boolean equals(Object a, Object b)
   如果 a 和 b 都为 null， 返回 true ; 如果只有其中之一为 null， 则返回 false ; 否 则 返 回a.equals(b)0
   ```

8. 为了避免发生类型错误， 可以使用 @Override 对覆盖超类的方法进行标记：

   ```java
   @Override public boolean equals(Object other)
   ```

### 2.3  hashCode 方法

1. 散列码 （ hash code ) 是由对象导出的一个整型值。 散列码是没有规律的。 如果 x 和 y 是两个不同的对象， x.hashCode( ) 与 y.hashCode( ) 基本上不会相同。

   ```java
   		//String 类使用下列算法计算散列码
   		int hash=0;
   		for (int i=0; i<length(); i++) {
   			hash=31*hash+charAt(i);
   		}
   ```

2. 由于 hashCode 方法定义在 Object 类中， 因此每个对象都有一个默认的散列码，其值为对象的存储地址。

   ```java
   		String s = "Ok";
   		StringBuilder sb = new StringBuilder(s);
   		System.out.println(s.hashCode() + " " + sb.hashCode()); //2556 617901222
   
   		String t = new String("Ok");
   		StringBuilder tb = new StringBuilder(t);
   		System.out.println(t.hashCode() + " " + tb.hashCode());  //2556 1746572565
   ```

   字符串 s 与 t 拥有相同的散列码， 这是因为字符串的散列码是由内容导出的。 而字符串缓冲 sb 与 tb 却有着不同的散列码， 这是因为在 StringBuffer 类中没有定义hashCode 方法，它的散列码是由 Object 类的默认 hashCode 方法导出的对象存储地址。

3. 如果重新定义 equals 方法， 就必须重新定义 hashCode 方法， 以便用户可以将对象插人到散列表中.

4. hashCode 方法应该返回一个整型数值（也可以是负数 )，并合理地组合实例域的散列码,以便能够让各个不同的对象产生的散列码更加均匀。

   ```java
   //Employee 类的 hashCode 方法。
   public int hashCode(){
   	return 7*name.hashCode()+11*new Double(salary).hashCode()+13*hireDay.hashCode();
   }
   ```

5. 可以做得更好。首先，最好使用 null 安全的方法 Objects.hashCode。 如果其参数为 null，这个方法会返回 0, 否则返回对参数调用 hashCode 的结果。另外， 使用静态方法 Double.hashCode 来避免创建 Double 对象：

   ```java
   public int hashCode(){
   	return 7*Objects.hashCode(name)+11*Double.hashCode(salary)+13*Objects.hashCode(hireDay);
   }
   ```

6. 还有更好的做法，需要组合多个散列值时，可以调用 ObjeCtS.hash 并提供多个参数。这个方法会对各个参数调用 Objects.hashCode， 并组合这些散列值。这样 Employee.hashCode 方法可以简单地写为：

   ```java
   public int hashCode(){
   	return Objects.hash(name,salary,hireDay);
   }
   ```

7. Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必须与 y.hashCode( ) 具有相同的值。例如， 如果用定义的 Employee.equals 比较雇员的 ID， 那么 hashCode 方法就需要散列 ID，而不是雇员的姓名或存储地址。

8. 如果存在数组类型的域， 那么可以使用静态的 Arrays.hashCode 方法计算一个散列码， 这个散列码由数组元素的散列码组成。

```java
java.util.Object
    int hashCode( )
    返回对象的散列码。 散列码可以是任意的整数， 包括正数或负数。两个相等的对象要求返回相等的散列码。

java.util.Objects
	static int hash(Object... objects )
	返回一个散列码，由提供的所有对象的散列码组合而得到。
	static int hashCode(Object a )
	如果 a 为 null 返回 0， 否则返回 a.hashCode() 0

java.lang.(lnteger|Long|Short|Byte|Double|Float|Character|Boolean) 
	static int hashCode((int11ong|short|byte|double|f1oat|char|boolean) value)
	返回给定值的散列码。

java.utii.Arrays 
	static int hashCode( type[] a )
	计算数组 a 的散列码。 组成这个数组的元素类型可以是 object，int，long, short, char,byte, boolean, float 或 double。

```

### 2.4  toString 方法

1. 在 Object 中还有一个重要的方法， 就是 toString 方法， 它用于返回表示对象值的字符串。

2. 绝大多数（但不是全部）的 toString 方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。 

   ```java
   	//Employee 类中的 toString 方法的实现：
   	public String toString(){
   		return "Employee[name="+name+",salary="+salary+",hireDay="+hireDay+"]";
   	}
   	//还可以设计得更好一些。最好通过调用 getClaSS( ).getName( ) 获得类名的字符串， 而不要将类名硬加到 toString方法中。
   	public String toString(){
   		return getClass().getName()+"[name="+name+",salary="+salary+",hireDay="+hireDay+"]";
   	}
   ```

3. toString 方法也可以供子类调用。设计子类的程序员也应该定义自己的 toString 方法，并将子类域的描述添加进去。如果超类使用了 getClass( ).getName( ), 那么子类只要调用 super.toString( ) 就可以了。

   ```java
   //Manager 类中的 toString 方法
   public String toString(){
   	return super.toString()+",[bonus="+bonus+"]";
   }
   ```

4. 随处可见 toString方法的主要原因是： 只要对象与一个字符串通过操作符“+” 连接起来，Java 编译就会自动地调用 toString 方法，以便获得这个对象的字符串描述。 在调用 x.toString( ) 的地方可以用 ""+x 替代。 这条语句将一个空串与 x 的字符串表示相连接。这里的 x 就是 x.toString( )。 与 toString 不同的是， 如果 x 是基本类型， 这条语句照样能够执行。

   ```java
   Point p=new Point(60,20);
   String messg="The current pisition is "+p;
   ```

   如果 x 是任意一个对象， 并调用  System.out.println(x);println 方法就会直接地调用 x.toString( )，井打印输出得到的字符串。

5. Object 类定义了 toString 方法， 用来打印输出对象所属的类名和散列码。 

   ```java
   System.out.println(System.out);  //java.io.PrintStream@24d46ca6
   ```

6.  数组继承了 object 类的 toString 方法， 数组类型将按照旧的格式打印。

   ```java
   		int[] numbers={3,5,7,9,0,12};
   		System.out.println(""+numbers);  //[I@8efb846  ,前缀 [I 表明是一个整型数组
   		System.out.println(Arrays.toString(numbers));  //[3, 5, 7, 9, 0, 12]
   		//要想打印多维数组（即， 数组的数组）则需要调用 Arrays.deepToString 方法。
   		int [][] numbers2={{3,4,5,6},{2,3,4},{2,1}};
   		System.out.println(Arrays.deepToString(numbers2));  //[[3, 4, 5, 6], [2, 3, 4], [2, 1]]
   ```

7. 强烈建议为自定义的每一个类增加 toString 方法。这样做不仅自己受益， 而且所有使用这个类的程序员也会从这个日志记录支持中受益匪浅。

```java
java.lang.Object
	Class getClass( )
	返回包含对象信息的类对象。稍后会看到 Java 提供了类运行时的描述， 它的内容被封装在 Class 类中。
	boolean equals(Object otherObject )
    比较两个对象是否相等， 如果两个对象指向同一块存储区域， 方法返回 true ; 否 则 方法返回 false。在自定义的类中， 应该覆盖这个方法。
    String toString( )
    返冋描述该对象值的字符串。在自定义的类中， 应该覆盖这个方法。

java.lang.Class 
    String getName( )
	返回这个类的名字。
     Class getSuperclass( )
	以 Class 对象的形式返回这个类的超类信息。

```

```java
import java.time.*;
import java.util.*;

class Employee{
	// instance fields
	private String name;
	private double salary;
	private LocalDate hireDay;

	//constructor
	public Employee(String n,double s,int year,int month,int day){
		name=n;
		salary=s;
		hireDay=LocalDate.of(year,month,day);
	}

	public int hashCode(){
		return Objects.hash(name,salary,hireDay);
	}

	public String toString(){
		return getClass().getName()+"[name="+name+",salary="+salary+",hireDay="+hireDay+"]";
	}

	//method
	public String getName(){
		return name;
	}
	public double getSalary(){
		return salary;
	}
	public LocalDate getHireDay(){
		return hireDay;
	}
	public void raiseSalary(double byPercent){
		double raise=salary*byPercent/100;
		salary+=raise;
	}
	public boolean equals(Object otherObject){
		if (this==otherObject) {
			return true;
		}
		if (otherObject==null) {
			return false;
		}
		if (getClass()!=otherObject.getClass()) {
			return false;
		}
		Employee other=(Employee) otherObject;
		return Objects.equals(name,other.name) && salary==other.salary && Objects.equals(hireDay,other.hireDay);
	}

}

class Manager extends Employee{
	//新增属性
	private double bonus;

	//子类构造器
	public Manager(String n,double s,int y,int m,int d){
		super(n,s,y,m,d);
		bonus=0;
	}
	public String toString(){
		return super.toString()+",[bonus="+bonus+"]";
	}

	//新增方法
	public void setBonus(double bonus){
		this.bonus=bonus;
	}

	//覆盖方法
	public double getSalary(){
		//调用超类 Employee 中的 getSalary 方法
		double baseSalary=super.getSalary();
		return baseSalary+bonus;
	}
	public boolean equals(Object otherObject){
		if (!super.equals(otherObject)) {
			return false;
		}
		Manager other=(Manager) otherObject;
		return bonus==other.bonus;
	}
}

public class TestBase{
	public static void main(String[] args){

		Employee staff1=new Employee("mane",20,2015,6,11);
		Employee staff2=staff1;
		Employee staff3=new Employee("mane",20,2015,6,11);
		Employee staff4=new Employee("Arnold",18,2006,6,6);
		System.out.println("staff1==staff2： "+(staff1==staff2));
		System.out.println("staff1==staff3： "+(staff1==staff3));
		System.out.println("staff1.equals(staff3):"+staff1.equals(staff3));
		System.out.println("staff1.equals(staff4):"+staff1.equals(staff4));

		System.out.println("staff4.toString(): "+staff4);

		Manager boss1=new Manager("kloop",50,2015,10,10);
		Manager boss2=new Manager("kloop",50,2015,10,10);
		boss1.setBonus(1000);

		System.out.println("boss1.toString(): "+boss1);
		System.out.println("boss2.equals(boss1): "+boss2.equals(boss1));

		System.out.println("staff1.hashCode(): "+staff1.hashCode());
		System.out.println("staff2.hashCode(): "+staff2.hashCode());
		System.out.println("staff3.hashCode(): "+staff3.hashCode());
		System.out.println("staff4.hashCode(): "+staff4.hashCode());
		System.out.println("boss1.hashCode(): "+boss1.hashCode());
		System.out.println("boss2.hashCode(): "+boss2.hashCode());
		
	}
}
/*
------Output------
staff1==staff2： true
staff1==staff3： false
staff1.equals(staff3):true
staff1.equals(staff4):false
staff4.toString(): Employee[name=Arnold,salary=18.0,hireDay=2006-06-06]
boss1.toString(): Manager[name=kloop,salary=50.0,hireDay=2015-10-10],[bonus=1000.0]
boss2.equals(boss1): false
staff1.hashCode(): -2045375115
staff2.hashCode(): -2045375115
staff3.hashCode(): -2045375115
staff4.hashCode(): 1996735023
boss1.hashCode(): -1544757064
boss2.hashCode(): -1544757064
*/
```



## 3  泛型数组列表

### 3.1   数组列表构造与定义

1. ArrayList 是一个采用类型参数（ type parameter) 的泛型类（ generic class )。为了指定数组列表保存的元素对象类型， 需要用一对尖括号将类名括起来加在后面。

2. Java SE 7 中， 可以省去右边的类型参数这被称为“ 菱形” 语法， 因为空尖括号<>就像是一个菱形。可以结合 new 操作符使用菱形语法。编译器会检查新值是什么。如果赋值给一个变量， 或传递到某个方法， 或者从某个方法返回， 编译器会检査这个变量、 参数或方法的泛型类型， 然后将这个类型放在<>中。

3. 使用 add 方法可以将元素添加到数组列表中。

   ```java
   	//声明和构造一个保存 Employee 对象的数组列表
   	ArrayList<Employee> staff2= new ArrayList<Employee>(100);
   	//Java SE 7 中， 可以省去右边的类型参数：
   	//ArrayList<Employee> staff2= new ArrayList<>();
   	staff2.add(new Employee("mane",20,2015,6,11));
   	staff2.add(new Employee("Arnold",18,2006,6,6));
   ```

4. 数组列表管理着对象引用的一个内部数组。最终， 数组的全部空间有可能被用尽。这就显现出数组列表的操作魅力： 如果调用 add 且内部数组已经满了， 数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。

5. 如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用ensureCapacity 方法：

   ```java
   staff2.ensureCapacity(lOO);
   //这个方法调用将分配一个包含 100 个对象的内部数组。然后调用 100 次 add, 而不用重新分配空间。
   //还可以把初始容量传递给 ArrayList 构造器：
   ArrayList<Employee> staff2 = new ArrayList<>(lOO);
   ```

   ```java
   //分配数组列表， 如下所示：
   new ArrayListo(lOO) // capacity is 100
   //它与为新数组分配空间有所不同：
   new Employee[100] // size is 100
   ```

   数组列表的容量与数组的大小有一个非常重要的区别。 如果为数组分配 100 个元素的存储空间， 数组就有 100 个空位置可以使用。 而容量为 100 个元素的数组列表只是拥有保存 100 个元素的潜力 （ 实际上， 重新分配空间的话， 将会超过丨00 ), 但是在最初，甚至完成初始化构造之后， 数组列表根本就不含有任何元素。

   ```java
   //size 方法将返回数组列表中包含的实际元素数目。 将返回 staff 数组列表的当前元素数量， 它等价于数组 a 的 a.length。
   System.out.println(staff2.size());  //2
   ```

6. 一旦能够确认数组列表的大小不再发生变化， 就可以调用 trimToSize 方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时， 再调用 trimToSize。

```java
java.util.ArrayList<E>
        ArrayList<E>()
        //构造一个空数组列表。
   		ArrayList<E>(int initialCapacity)
		//用指定容量构造一个空数组列表。 参数： initalCapacity  数组列表的最初容量
		boolean add(E obj)
		//在数组列表的尾端添加一个元素。 永远返回 true。参数：obj 添加的元素
		int size()
		//返回存储在数组列表中的当前元素数量。（这个值将小于或等于数组列表的容量。)
		void ensureCapacity(int capacity)
		//确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。 参数：capacity  需要的存储容量
		void trimToSize()
		//将数组列表的存储容量削减到当前尺寸。
    
```

### 3.2  访问数组列表元素

1. 数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。 其原因是 ArrayList 类并不是 Java 程序设计语言的一部分；它只是一个由某些人编写且被放在标准库中的一个实用类。

2. 使用 get 和 set 方法实现访问或改变数组元素的操作，而不使用人们喜爱的 [ ] 语法格式。只有 i 小于或等于数组列表的大小时， 才能够调用 list.set(i，x)。

   ```java
   		staff2.set(i,obj);
   		Employee e=staff2.get(i);
   
   		System.out.println(staff2.size());  // 2
   		Manager boss1=new Manager("kloop",50,2015,10,10);
   		staff2.add(1,boss1);
   		System.out.println(staff2.size());  // 3
   
   		Employee e=staff2.remove(1);
   		System.out.println(staff2.size());  // 2
   
   		for (Employee e:staff2){
   			System.out.println(e.getName());
   		}
   		//相同的效果
   		for (int i=0; i<staff2.size(); i++) {
   			System.out.println(staff2.get(i).getName());
   		}
   ```

3. 使用 add 方法为数组添加新元素， 而不要使用 set 方法， 它只能替换数组中已经存在的元素内容。

4. 除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素， 使用带索引参数的 add 方法。为了插人一个新元素，位于 n 之后的所有元素都要向后移动一个位置。如果插人新元素后， 数组列表的大小超过了容量， 数组列表就会被重新分配存储空间。

5. 同样地，可以从数组列表中间删除一个元素。位于这个位置之后的所有元素都向前移动一个位置， 并且数组的大小减 1，

6. 对数组实施插人和删除元素的操作其效率比较低。对于小型数组来说， 这一点不必担心。但如果数组存储的元素数比较多， 又经常需要在中间位置插入、删除元素， 就应该考虑使用链表了。

7. 可以使用“ foreach” 循环遍历数组列表。

```java
	java.util.ArrayList<T>
		void set(int index,E obj)
		//设置数组列表指定位置的元素值， 这个操作将覆盖这个位置的原有内容。
		E get(int index)
		//获得指定位置的元素值。
		void add(int index,E obj)
		//向后移动元素， 以便插入元素。
		E remove(int index)
		//删除一个元素，并将后面的元素向前移动。被删除的元素由返回值返回。
```

### 3.2  类型化与原始数组列表的兼容性

鉴于兼容性的考虑， 编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象， 就将所有的类型化数组列表转换成原始 ArrayList 对象。 在程序运行时， 所有的数组列表都是一样的， 即没有虚拟机中的类型参数。 因此， 类型转换 （ ArrayList) 和 ( ArrayList<Employee> ) 将执行相同的运行时检查。

## 4  对象包装器与自动装箱

### 4.1  装箱与拆箱

1. 有时， 需要将 int 这样的基本类型转换为对象。 所有的基本类型都冇一个与之对应的类。例如，丨nteger 类对应基本类型 int。通常， 这些类称为包装器 （ wrapper )。这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character 、Void 和 Boolean (前6 个类派生于公共的超类 Number)。

2. 对象包装器类是不可变的， 即一旦构造了包装器， 就不允许更改包装在其中的值。同时， 对象包装器类还是 final, 因此不能定义它们的子类。

   ```java
           //尖括号中的类型参数不允许是基本类型， 也就是说，不允许写成 ArrayList<int>。就用到了 Integer 对象包装器类。
           ArrayList<Integer> list=new ArrayList<>();
           list.add(10);  //将自动地变换成		list.add(Integer.valueOf(10));
           int n = list.get(i);  //自动地拆箱		int n=list.get(i).intValue();
   
           Integer x=66;
           x++;  //编译器将自动地插人一条对象拆箱的指令， 然后进行自增计算， 最后再将结果装箱。
   
   		Integer a=100;
   		Integer b=100;
   		System.out.println(a==b);  //true
   		System.out.println(a.equals(b));  //true
   
   		Integer c=1000;
   		Integer d=1000;
   		System.out.println(c==d);  //false
   		System.out.println(c.equals(d));  //true
   
   		Integer n2=null;
   		System.out.println(2*n2);
   		//Exception in thread "main" java.lang.NullPointerException: 
   		//Cannot invoke "java.lang.Integer.intValue()" because "<local8>" is null
   
   		Integer n=20;
   		Double d=23.4;
   		System.out.println(n<d ? n:d);  //20.0
   ```

   由于每个值分别包装在对象中， 所以 ArrayList<lnteger> 的效率远远低于 int[ ] 数组。 因此， 应该用它构造小型集合， 其原因是此时程序员操作的方便性要比执行效率更加重要。

3. 调用list.add(3);将自动地变换成list.add(Integer.value0f(3));这种变换被称为自动装箱（autoboxing )。

4. 相反地， 当将一个 Integer 对象赋给一个 int 值时， 将会自动地拆箱。

5. 甚至在算术表达式中也能够自动地装箱和拆箱。

6.  == 运算符也可以应用于对象包装器对象， 只不过检测的是对象是否指向同一个存储区域， 如果将经常出现的值包装到同一个对象中，这种比较就有可能成立。这种不确定的结果并不是我们所希望的。 解决这个问题的办法是在两个包装器对象比较时调用 equals 方法。

7.  自动装箱规范要求 boolean、byte、 char<=127， 介于-128 ~ 127 之间的 short 和int 被包装到固定的对象中。 

8.  由于包装器类引用可以为 null, 所以自动装箱有可能会抛出一个 NullPointerException 异常。

9. 如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱，提升为 double, 再装箱为 Double:

10. 装箱和拆箱是编译器认可的， 而不是虚拟机。编译器在生成类的字节码时， 插人必要的方法调用。虚拟机只是执行这些字节码。

11. 可以将某些基本方法放置在包装器中， 例如， 将一个数字字符串转换成数值。

    ```java
    		//将字符串转换成整型
    		String str="34";
    		int x=Integer.parseInt(str);
    		System.out.println("x="+x);  //x=34
    //这里与 Integer 对象没有任何关系， parselnt 是一个静态方法。 但 Integer 类是放置这个方法的一个好地方 
    ```

### 4.2  java.lang.Integer

```java
int intValue( )
    以 int 的形式返回 Integer 对象的值（在 Number 类中覆盖了 intValue方法）。
static String toString(int i )
	以一个新 String 对象的形式返回给定数值 i 的十进制表示。
static String toString(int i ,int radix)
	返回数值 i 的基于给定 radix 参数进制的表示。	   
static int parselnt(String s)
static int parseInt(String s,int radix)
	返回字符串 s 表示的整型数值， 给定字符串表示的是十进制的整数 （第一种方法)，或者是 radix 参数进制的整数 （第二种方法 )。
static Integer valueOf(String s)
static Integer valueOf(String s, int radix)
  	返回用 s 表示的整型数值进行初始化后的一个新 Integer 对象， 给定字符串表示的是十进制的整数 （第一种方法 )， 或者是 radix 参数进制的整数 （第二种方法 )。
    
java.text.NumberFormat
    Number parse(String s)
	返回数字值，假设给定的 String 表示了一个数值。
```

## 5  参数数量可变的方法

1. 实际上，printf 方法接收两个参数， 一个是格式字符串， 另一个是 Object ] 数组， 其中保存着所有的参数 （如果调用者提供的是整型数组或者其他基本类型的值， 自动装箱功能将把它们转换成对象 )。对于 printf 的实现者来说，Object… 参数类型与 Object[ ] 完全一样。编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上， 并在必要的时候进行自动装箱。

   ```java
   		int n=66;
   		System.out.printf("%d\n",n);  //66
   		System.out.printf("%d \t%s\n",n,"Arnold");  //66 	Arnold
   		System.out.printf("%d \t%s\n",new Object[]{Integer.valueOf(66),"Arnold"});  //66 	Arnold
   ```

2. 用户自己也可以定义可变参数的方法， 并将参数指定为任意类型， 甚至是基本类型。

   ```java
   public class TestBase2{
   	public static double max(double... values){
   		double maxValue=Double.NEGATIVE_INFINITY;
   		for (double v:values){
   			if (v>maxValue){
   				maxValue=v;
   			}
   		}
   		return maxValue;
   	}
   	public static void main(String[] args){
   		//编译器将 new double[ ] {3.5,6.5,-3.4,20}传递给 max 方法。
   		System.out.println(max(3.5,6.5,-3.4,20));  //20.0
   		
   	}
   }
   ```

3. 允许将一个数组传递给可变参数方法的最后一个参数。因此， 可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。

## 6  枚举类

1. 在比较两个枚举类型的值时， 永远不需要调用 equals, 而直接使用“= =” 就可以了。如果需要的话， 可以在枚举类型中添加一些构造器、 方法和域。 当然， 构造器只是在构造枚举常量的时候被调用。

   ```java
   import java.util.*;
   
   //使用enum定义枚举类
   enum SeasonEnum{
   	SPRING("春天","春风又绿江南岸"),
   	SUMMER("夏天","映日荷花别样红"),
   	AUTUMN("秋天","秋水共长天一色"),
   	WINTER("冬天","窗含西岭千秋雪");
   
   	private final String seasonName;
   	private final String seasonDesc;
   
   	private SeasonEnum(String seasonName,String seasonDesc){
   		this.seasonName=seasonName;
   		this.seasonDesc=seasonDesc;
   	}
   	public String getSeasonName(){
   		return seasonName;
   	}
   	public String getSeasonDesc(){
   		return seasonDesc;
   	}
   }
   
   public class TestBase2{
   
   	public static void main(String[] args){
   		System.out.println(SeasonEnum.SPRING.toString());  //SPRING
   		SeasonEnum s=Enum.valueOf(SeasonEnum.class,"SUMMER");
   		System.out.println(s);  //SUMMER
   
   		SeasonEnum[] seasons=SeasonEnum.values();
   		System.out.println(Arrays.toString(seasons));  //[SPRING, SUMMER, AUTUMN, WINTER]
   
   		System.out.println(SeasonEnum.AUTUMN.ordinal());  //2
   		
   	}
   }
   ```

2. 所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。 其中最有用的一个是 toString， 这个方法能够返回枚举常量名。 toString 的逆方法是静态方法 valueOf。

3. 每个枚举类型都有一个静态的 values 方法， 它将返回一个包含全部枚举值的数组。

4. ordinal 方 法 返 冋 enum 声 明 中 枚 举 常 量 的 位 置， 位 置 从 0 开始计数。

```java
java.Iang.Enum <E> 
    •static Enum valueOf( Cl ass enumClass , String name )
	返回指定名字、给定类的枚举常量。
	•String toString()
	返回枚举常量名。
    •int ordinal ( )
    返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。
    •int compareTo( E other )
    如果枚举常量出现在 Other 之前， 则返回一个负值；如果 this=other， 则返回 0; 否则，    返回正值。枚举常量的出现次序在 enum 声明中给出。
```













