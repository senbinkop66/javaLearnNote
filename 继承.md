# 继承

## 1  类、超类和子类

### 1.1  定义子类

1. Java 与 C++ 定义继承类的方式十分相似。 Java 用关键字 extends 代替了 C++中的冒号（：）。 在 Java 中， 所有的继承都是公有继承， 而没有 C++ 中的私有继承和保护继承。

2. 关键字 extends 表明正在构造的新类派生于一个已存在的类。 已存在的类称为超类( superclass )、 基类（ base class) 或父类（parent class); 

3. 新类称为子类（subclass)、 派生类(derived class) 或孩子类（child class)。超类和子类是 Java 程序员最常用的两个术语， 而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这些都是继承时使用的术语。

4. 超类并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反，子类比超类拥有的功能更加丰富。

5. 前缀“ 超” 和“ 子” 来源于计算机科学和数学理论中的集合语言的术语。所有雇员组成的集合包含所有经理组成的集合。 可以这样说， 雇员集合是经理集合的超集， 也可以说， 经理集合是雇员集合的子集。

6. 在通过扩展超类定义子类的时候， 仅需要指出子类与超类的不同之处。 因此在设计类的时候，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中，这种将通用的功能放到超类的做法，在面向对象程序设计中十分普遍。

   ```java
   class Manager extends Employee{
   	//新增属性
   	private double bonus;
   
   	//新增方法
   	public void setBonus(double bonus){
   		this.bonus=bonus;
   	}
   }
   ```

### 1.2  覆盖方法

1. super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编译器调用超类方法的特殊关键字。

2. 在子类中可以增加域、 增加方法或覆盖超类的方法， 然而绝对不能删除继承的任何域和方法。

3. 在 Java 中使用关键字 super 调用超类的方法。super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。

4. 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类方法是 public, 子类方法一定要声明为 public。

   经常会发生这类错误：在声明子类方法的时候， 遗漏了 public 修饰符。此时， 编译器将会把它解释为试图提供更严格的访问权限。
   ```java
   	//覆盖方法
   	public double getSalary(){
   		//调用超类 Employee 中的 getSalary 方法
   		double baseSalary=super.getSalary();
   		return baseSalary+bonus;
   	}
   ```

### 1.3  子类构造器

1. 由于 Manager 类的构造器不能访问 Employee 类的私有域， 所以必须利用 Employee 类的构造器对这部分私有域进行初始化， 我们可以通过 super 实现对超类构造器的调用。使用super 调用构造器的语句必须是子类构造器的第一条语句。

2. 如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。 

3. 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器’ 则 Java 编译器将报告错误。

4. 构造参数既可以传递给本类 （ this) 的其他构造器， 也可以传递给超类（super ) 的构造器。

   ```java
   	//子类构造器
   	public Manager(String n,double s,int y,int m,int d){
   		super(n,s,y,m,d);
   		bonus=0;
   	}
   ```

   1. 一个对象变量（例如， 变量 e) 可以指示多种实际类型的现象被称为多态（polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（ dynamic binding)。虚拟机知道e 实际引用的对象类型， 因此能够正确地调用相应的方法。
   2. 在 Java 中， 不需要将方法声明为虚拟方法。 动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征， 可以将它标记为 final 

```java
		Employee[] staff=new Employee[4];

		staff[0]=new Employee("mane",20,2015,6,11);
		staff[1]=new Employee("Alison",23,2018,6,26);
		staff[2]=new Employee("Arnold",18,2006,6,6);
		Manager boss=new Manager("kloop",50,2015,10,10);
		boss.setBonus(1000);
		staff[3]=boss;
		
		for (Employee e:staff){
			e.raiseSalary(5);
		}

		for (Employee e:staff){
			System.out.println("name:"+e.getName()+",salary:"+e.getSalary()+",hireDay:"+e.getHireDay());
		}

```

### 1.4  继承层次

1. 继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次（ inheritance hierarchy )。在继承层次中， 从某个特定的类到其祖先的路径被称为该类的继承链 ( inheritance chain) 。
2. 通常， 一个祖先类可以拥有多个子孙继承链。
3. Java 不支持多继承。

### 1.5  多 态

1. 有一个用来判断是否应该设计为继承关系的简单规则， 这就是“ is-a” 规则， 它表明子类的每个对象也是超类的对象。

2. “is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。可以将一个子类的对象赋给超类变量。

   ```java
   Employee e;
   e = new Employee(. . .);
   // Employee object expected
   e = new Manager(. . .); // OK, Manager can be used as well
   ```

   

3. 在 Java 程序设计语言中， 对象变量是多态的。 一个 Employee 变量既可以引用一个Employee 类对象， 也可以引用一个 Employee 类的任何一个子类的对象（例如， Manager、Executive、Secretary 等）。

   ```java
   //可以这样调用
   boss.setBonus(5000); // OK
   //但不能这样调用
   staff[0].setBonus(5000); // Error
   ```

4. 不能将一个超类的引用赋给子类变量。

   ```java
   Manager m = staff[i]; // Error
   ```

5. 在 Java 中， 子类数组的引用可以转换成超类数组的引用， 而不需要采用强制类型转换。

   ```java
   Manager[] managers = new Manager[10];
   //将它转换成 Employee[] 数组完全是合法的：
   Employee[] staff = managers; // OK
   ```

   为了确保不发生这类错误， 所有数组都要牢记创建它们的元素类型， 并负责监督仅将类型兼容的引用存储到数组中。例如， 使用 new managers[10] 创建的数组是一个经理数组。如果试图存储一个 Employee 类型的引用就会引发 ArrayStoreException 异常。

### 1.6  理解方法调用

下面假设要调用 x.f(args)， 隐式参数 x 声明为类 C 的一个对象。下面是调用过程的详细描述：

1. 编译器査看对象的声明类型和方法名。

   假设调用 x.f(param)，且隐式参数 x 声明为 C类的对象。需要注意的是： 有可能存在多个名字为 f, 但参数类型不一样的方法。例如， 可能存在方法 f(im) 和方法 String)。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法 （超类的私有方法不可访问）。

   至此， 编译器已获得所有可能被调用的候选方法。

2. 接下来，编译器将査看调用方法时提供的参数类型。

   如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配， 就选择这个方法。这个过程被称为**重栽解析** （ overloading resolution)。 例如， 对于调用 x.f(“Hello” ）来说， 编译器将会挑选 f(String)， 而不是 f(int)。由于允许类型转换（ int 可以转换成 double, Manager 可以转换成 Employee, 等等)， 所以这个过程可能很复杂。

   如果编译器没有找到与参数类型匹配的方法， 或者发现经过类型转换后有多个方法与之匹配， 就会报告一个错误。

   至此， 编译器已获得需要调用的方法名字和参数类型。

3. 如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定（ static binding)。

    与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。 在我们列举的示例中， 编译器采用动态绑定的方式生成一条调用 f(String) 的指令。

4. 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。

   假设 x 的实际类型是 D，它是 C 类的子类。 如果 D 类定义了方法 f(String)，就直接调用它；否则， 将在 D 类的超类中寻找 f(String)， 以此类推。

   - 每次调用方法都要进行搜索，时间开销相当大。因此， 虚拟机预先为每个类创建了一个方法表（ method table), 其中列出了所有方法的签名和实际调用的方法。
   - 这样一来，在真正调用方法的时候， 虚拟机仅查找这个表就行了。在前面的例子中， 虚拟机搜索 D 类的方法表， 以便寻找与调用 f(Sting) 相K配的方法。这个方法既有可能是 D.f(String), 也有可能是X.f(String), 这里的 X 是 D 的超类。这里需要提醒一点， 如果调用 super.f(param), 编译器将对隐式参数超类的方法表进行搜索。
   - 动态绑定有一个非常重要的特性： 无需对现存的代码进行修改，就可以对程序进行扩展。
     假设增加一个新类 Executive, 并且变量 e 有可能引用这个类的对象， 我们不需要对包含调用e.getSalary() 的代码进行重新编译。 如果 e 恰好引用一个 Executive 类的对象， 就会自动地调用 Executive.getSalaryO 方法。


### 1.7  阻止继承：final 类和方法

1. 不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。 例如， 假设希望阻止人们定义Executive 类的子类，就可以在定义这个类的时候’使用 final 修饰符声明。

2. 类中的特定方法也可以被声明为 final。 如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法 )。

   ```java
   	public final String getDepartment(){
   		return "Manager";
   	}
   }
   
   public final class Executive extends Manager{
   
   }
   ```

3.  对于 final 域来说， 构造对象之后就不允许改变它们的值了。 不过， 如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。

4. 将方法或类声明为 final 主要目的是： **确保它们不会在子类中改变语义**。

5. 如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为**内联( inlining)**。 例如，内联调用 e.getName( ) 将被替换为访问 e.name 域。这是一项很有意义的改进， 这是由于 CPU 在处理调用方法的指令时， 使用的分支转移会扰乱预取指令的策略， 所以，这被视为不受欢迎的。然而， 如果 getName 在另外一个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作， 因此也就不能对它进行内联处理了。

6.  虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系， 并能够检测出类中是否真正地存在覆盖给定的方法。 

### 1.8  强制类型转换

1. 将一个类型强制转换成另外一个类型的过程被称为类型转换。Java 程序设计语言提供了一种专门用于进行类型转换的表示法。

   ```java
   double x = 3.405;
   int nx = (int) x;
   //将表达式 x 的值转换成整数类型， 舍弃了小数部分
   ```

2. 正像有时候需要将浮点型数值转换成整型数值一样， 有时候也可能需要将某个类的对象引用转换成另外一个类的对象引用。

3. 对象引用的转换语法与数值表达式的类型转换类似， 仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。

   ```java
   Manager boss = (Manager) staff[0]:
   ```

4. 进行类型转换的唯一原因是：**在暂时忽视对象的实际类型之后， 使用对象的全部功能**。

5. 在 Java 中， 每个对象变量都属于一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。例如，staff[i] 引用一个 Employee 对象（因此它还可以引用 Manager对象 )。

6. 将一个值存人变量时， 编译器将检查是否允许该操作。将一个了-类的引用赋给一个超类变量， 编译器是允许的。但将一个超类的引用赋给一个子类变量， 必须进行类型转换， 这样才能够通过运行时的检査。

7. 在进行类型转换之前， 先查看一下是否能够成功地转换。这个过程简单地使用instanceof 操作符就可以实现。 如果这个类型转换不可能成功， 编译器就不会进行这个转换。

   ```java
   //Manager boss = (Manager) staff[1]; // Error
   if (staff[1] instanceof Manager)
   {
   	Manager boss = (Manager) staff[1];
   }
   String c = (String) staff[1]; //将会产生编译错误， 这是因为 String 不是 Employee 的子类。
   ```

8. 只能在继承层次内进行类型转换。在将超类转换成子类之前，应该使用 instanceof 进行检查。

9. 实际上，通过类型转换调整对象的类型并不是一种好的做法。 在一般情况下，应该尽量少用类型转换和 instanceof 运算符。

### 1.9  抽象类

1. 如果自下而上在类的继承层次结构中上移， 位于上层的类更具有通用性，甚至可能更加抽象。 从某种角度看， 祖先类更加通用， 人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。

   例如， 考虑一下对 Employee 类层次的扩展。一名雇员是一个人， 一名学生也是一个人。下面将类 Person 和类 Student 添加到类的层次结构中。

2. 包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外， 抽象类还可以包含具体数据和具体方法。

3. 抽象方法充当着占位的角色， 它们的具体实现在子类中。

4. 扩展抽象类可以有两种选择。一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。

5. 类即使不含抽象方法，也可以将类声明为抽象类。

6. 抽象类不能被实例化。也就是说， 如果将一个类声明为 abstract, 就不能创建这个类的对象。

7. 可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象。

   ```java
   Person p = new Student("mane" , "forward");
   ```

   ```
   
   ```

   

