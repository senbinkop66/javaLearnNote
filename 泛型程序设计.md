# 泛型程序设计

##  1. 使用泛型程序设计

### 1.1  类型参数的好处

泛型程序设计（Generic programming) 意味着编写的代码可以被很多不同类型的对象所重用。

1. 在 Java 中增加范型类之前， 泛型程序设计是用继承实现的。ArrayList 类只维护一个Object 引用的数组。这种方法有两个问题。当获取一个值时必须进行强制类型转换。

   ```java
   ArrayList files = new ArrayList()；
   String filename = (String) files.get(O);
   //此外，这里没有错误检査。可以向数组列表中添加任何类的对象。
   files.add(new File("..."));
   //对于这个调用， 编译和运行都不会出错。然而在其他地方， 如果将 get 的结果强制类型转换为 String 类型， 就会产生一个错误。
   ```

2. 泛型提供了一个更好的解决方案： 类型参数 （type parameters)。ArrayList 类有一个类型参数用来指示元素的类型。

```java
ArrayList<String> files = new ArrayList<String>();
ArrayList<String> files = new ArrayList<>();  //省略的类型可以从变量的类型推断得出。
//编译器也可以很好地利用这个信息。 当调用 get 的时候， 不需要进行强制类型转换， 编译器就知道返回值类型为 String，而不是 Object
String filename = files.get(0);
//编译器还知道 ArrayList<String> 中 add 方法有一个类型为 String 的参数。 这将比使用Object 类型的参数安全一些。现在， 编译器可以进行检査，避免插人错误类型的对象。
files.add(new File("..."));  //无法通过编译的,仅能添加 String Object,
```

3. 出现编译错误比类在运行时出现类的强制类型转换异常要好得多。
4. 类型参数的魅力在于：使得程序具有更好的可读性和安全性。

### 1.2  怎么能使用泛型程序

1. 实现一个泛型类并没有那么容易。 对于类型参数， 使用这段代码的程序员可能想 要内置 （ plugin) 所有的类。 他们希望在没有过多的限制以及混乱的错误消息的状态下， 做 所有的事情。因此， 一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途。
2. 泛型程序设计划分为 3 个能力级别。
   - 基本级别是， 仅仅使用泛型类—典型的是像 ArrayList 这样的集合—不必考虑它们的工作方式与原因。大多数应用程序员将会停留在这 一级别上，直到出现了什么问题。 
   - 当把不同的泛型类混合在一起时， 或是在与对类型参数一 无所知的遗留的代码进行衔接时， 可能会看到含混不清的错误消息。 如果这样的话， 就需要 学习 Java 泛型来系统地解决这些问题， 而不要胡乱地猜测。
   - 当然， 最终可能想要实现自己的 泛型类与泛型方法。

## 2  定义简单泛型类

1. 一个泛型类（generic class) 就是具有一个或多个类型变量的类。使用一个简单的Pair 类作为例子。对于这个类来说， 我们只关注泛型，而不会为数据存储的细节烦恼。

   ```java
   class Pair<T>{
       //类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。
   	private T first;
   	private T second;
   
   	public Pair(){
   		first=null;
   		second=null;
   	}
   	public Pair(T first,T second){
   		this.first=first;
   		this.second=second;
   	}
   	public T getFirst(){
   		return first;
   	}
   	public T getSecond(){
   		return second;
   	}
   	public void setFirst(T newValue){
   		first=newValue;
   	}
   	public void setSecond(T newValue){
   		second=newValue;
   	}
   ```

2. Pair 类引人了一个类型变量 T，用尖括号 ( < >) 括起来，并放在类名的后面。泛型类可以有多个类型变量。

3. 类型变量使用大写形式， 且比较短， 这是很常见的。在 Java 库中， 使用变量 E 表示集合的元素类型， K 和 V 分别表示表的关键字与值的类型。T ( 需要时还可以用临近的字母 U 和 S) 表示“ 任意类型”。

4. 用具体的类型替换类型变量就可以实例化泛型类型，换句话说，泛型类可看作普通类的工厂。 例如：

   ```java
   	Pair<String>
       //可以将结果想象成带有构造器的普通类：
       	Pair<String>()
   		Pair<String>(String, String)
       //和方法：
         	String getFirst()
           String getSecond()
           void setFirst(String)
           void setSecond(String)
   ```

   ```java
   import java.util.*;
   import java.io.*;
   
   class Pair<T>{
   	private T first;
   	private T second;
   
   	public Pair(){
   		first=null;
   		second=null;
   	}
   	public Pair(T first,T second){
   		this.first=first;
   		this.second=second;
   	}
   	public T getFirst(){
   		return first;
   	}
   	public T getSecond(){
   		return second;
   	}
   	public void setFirst(T newValue){
   		first=newValue;
   	}
   	public void setSecond(T newValue){
   		second=newValue;
   	}
   }
   
   class ArrayAlg{
   	public static Pair<String> minmax(String[] a){
   		if (a==null || a.length==0) return null;
   		String min=a[0];
   		String max=a[0];
   		for (int i=1; i<a.length; i++) {
   			if (min.compareTo(a[i])>0) min=a[i];
   			if (max.compareTo(a[i])<0) max=a[i];
   		}
   		return new Pair<>(min,max);
   	}
   }
   
   public class TestBase4{
   	public static void main(String[] args){
   		String[] names={"mane","Alison","Arnold","salah"};
   		Pair<String> mm=ArrayAlg.minmax(names);
   		System.out.println("min="+mm.getFirst());
   		System.out.println("max="+mm.getSecond());
   	}
   }
   /*
   ------Output------
   min=Alison
   max=salah
   */
   ```

## 3  泛型方法

1. 可以定义一个带有类型参数的简单方法。

   ```java
   	public static <T> T getMiddle(T... a){
   		return a[a.length/2];
   	}
   ```

   这个方法是在普通类中定义的， 而不是在泛型类中定义的。然而，这是一个泛型方法，可以从尖括号和类型变量看出这一点。注意，类型变量放在修饰符（这里是 public static) 的后面，返回类型的前面。

2. 泛型方法可以定义在普通类中，也可以定义在泛型类中。

3. 当调用一个泛型方法时,在方法名前的尖括号中放入具体的类型：

   ```java
   String middle=ArrayAlg.<String>getMiddle(names);  //Arnold
   ```

   在这种情况（实际也是大多数情况）下，方法调用中可以省略 <String> 类型参数。 编译器有足够的信息能够推断出所调用的方法。它用 names 的类型（即 String[ ]) 与泛型类型 T[ ]进行匹配并推断出 T 一定是 String。也就是说，可以调用

   ```java
   String middle=ArrayAlg.getMiddle(names);
   ```

4. 乎在大多数情况下，对于泛型方法的类型引用没有问题。 偶尔， 编译器也会提示错误， 此时需要解译错误报告。

   ```java
   double middle2 = ArrayAlg.getMiddle(3.14, 1729, 0);  //不兼容的类型: 推断类型不符合上限
   ```

   

## 4  类型变量的限定

1. 有时，类或方法需要对类型变量加以约束。

   ```java
   	public static <T> T min(T[] a){
   		if (a==null || a.length==0) return null;
   		T smallest=a[0];
   		for (int i=1; i<a.length; i++) {
   			if (smallest.compareTo(a[i])>0) smallest=a[i];
   		}
   		return smallest;
   	}
   ```

   变量 smallest 类型为 T, 这意味着它可以是任何一个类的对象。怎么才能确信 T 所属的类有 compareTo 方法呢？

   解决这个问题的方案是将 T 限制为实现了 Comparable 接口（只含一个方法 compareTo 的标准接口）的类。可以通过对类型变量 T 设置限定（bound) 实现这一点：

   ```java
   public static <T extends Comparable> T min(T[] a)
       //
     	String min1=ArrayAlg.<String>min(names);
   	System.out.println(min1);  //Alison
   ```

   实际上 Comparable 接口本身就是一个泛型类型。目前， 我们忽略其复杂性以及编译器产生的警告。

2. 在此为什么使用关键字 extends 而不是 implements ? 毕竟，Comparable 是一个接口。下面的记法

   **<T extends BoundingType〉**

   表示 T 应该是绑定类型的子类型 （subtype)。 T 和绑定类型可以是类， 也可以是接口。**选择关键字 extends 的原因是更接近子类的概念**， 并且 Java 的设计者也不打算在语言中再添加一个新的关键字（如 sub)。

   一个类型变量或通配符可以有多个限定， 例如：

   **T extends Comparable & Serializable** 

   限定类型用“ &” 分隔， 而逗号用来分隔类型变量。

3. 在 Java 的继承中， 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。 如果用一个类作为限定，它必须是限定列表中的第一个。

```java
import java.util.*;
import java.io.*;
import java.time.*;

class Pair<T>{
	private T first;
	private T second;

	public Pair(){
		first=null;
		second=null;
	}
	public Pair(T first,T second){
		this.first=first;
		this.second=second;
	}
	public T getFirst(){
		return first;
	}
	public T getSecond(){
		return second;
	}
	public void setFirst(T newValue){
		first=newValue;
	}
	public void setSecond(T newValue){
		second=newValue;
	}
}

class ArrayAlg{
	public static <T extends Comparable> Pair<T> minmax(T[] a){
		if (a==null || a.length==0) return null;
		T min=a[0];
		T max=a[0];
		for (int i=1; i<a.length; i++) {
			if (min.compareTo(a[i])>0) min=a[i];
			if (max.compareTo(a[i])<0) max=a[i];
		}
		return new Pair<>(min,max);
	}
	public static <T> T getMiddle(T... a){
		return a[a.length/2];
	}
	public static <T extends Comparable> T min(T[] a){
		if (a==null || a.length==0) return null;
		T smallest=a[0];
		for (int i=1; i<a.length; i++) {
			if (smallest.compareTo(a[i])>0) smallest=a[i];
		}
		return smallest;
	}
}

public class TestBase4{
	public static void main(String[] args){
		String[] names={"mane","Alison","Arnold","salah"};
		Pair<String> mm=ArrayAlg.minmax(names);
		System.out.println("min="+mm.getFirst());
		System.out.println("max="+mm.getSecond());
		String middle=ArrayAlg.<String>getMiddle(names);
		System.out.println(middle);
		
		String min1=ArrayAlg.<String>min(names);
		System.out.println(min1);  //Alison

		LocalDate[] dates={
			LocalDate.of(1996,11,11),
			LocalDate.of(1889,7,23),
			LocalDate.of(1919,2,1),
			LocalDate.of(2021,11,24),
		};
		Pair<LocalDate> mm2=ArrayAlg.minmax(dates);
		System.out.println("min="+mm2.getFirst());  //min=1889-07-23
		System.out.println("max="+mm2.getSecond());  //max=2021-11-24

	}
}

```

