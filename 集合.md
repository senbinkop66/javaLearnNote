# 集合

## 1  Java 集合框架

### 1.1  将集合的接口与实现分离

1. 与现代的数据结构类库的常见情况一样， Java 集合类库也将接口 （ interface) 与 实 现(implementation) 分离。

2. 队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列。 队列通常有两种实现方式： 一种是使用循环数组； 另一种是使用链表 。

3. 如果需要一个循环数组队列， 就可以使用 ArrayDeque 类。 如果需要一个链表队列， 就直接使用 LinkedList类， 这个类实现了 Queue 接口。

4. 当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此， 只有在构建集合对象时，使用具体的类才有意义。可以使用接口类型存放集合的引用。

   ```java
   		
   		Queue<Person> persons=new CircularArrayQueue<>(100);
   		persons.add(new Person("mane"));
   		//
   		Queue<Person> persons=new LinkedListQueue<>(100);
   		persons.add(new Person("mane"));
   ```

5. 利用这种方式，一旦改变了想法， 可以轻松地使用另外一种不同的实现。只需要对程序的一个地方做出修改， 即调用构造器的地方。 如果觉得 LinkedListQueue 是个更好的选择，就将代码修改。

6. 循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。

### 1.2  Collection 接口

1. 在 Java 类库中，集合类的基本接口是 Collection 接口。这个接口有两个基本方法

   ```java
   public interface Collection<E>{
   	boolean add(E element);  //将一个元素添加到集合中。如果由于这个调用改变了集合，返回 true。
   	Iterator<E> iterator();
   	...;
   }
   ```

   除了这两个方法之外，还有几个方法，

   - add 方法用于向集合中添加元素。 如果添加元素确实改变了集合就返回 true, 如果集合没有发生变化就返回 false。
   - iterator 方法用于返回一个实现了 Iterator 接口的对象。 可以使用这个迭代器对象依次访问集合中的元素。

### 1.3  迭代器

Iterator 接口包含 4 个方法：

```java
public interface Iterator<E>{
	E next();  //返回将要访问的下一个对象。 如果已经到达了集合的尾部， 将拋出一个 NoSuchElementException。
	boolean hasNext();  //如果存在可访问的元素， 返回 true。
	void remove();  //删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化， 这个方法将抛出一个 IllegalStateException。
	default void forEachRemaining(Consumer<? super E> action);
}
```

1. 通过反复调用 next 方法，可以逐个访问集合中的每个元素。但是， 如果到达了集合的末尾，next 方法将抛出一个 NoSuchElementException。 
2. 因此，需要在调用 next 之前调用 hasNext方法。如果迭代器对象还有多个供访问的元素， 这个方法就返回 true。
3. 如果想要査看集合中的所有元素，就请求一个迭代器，并在 hasNext 返回 true 时反复地调用 next 方法。
4. Collection 接口扩展了 Iterable 接口。因此， 对于标准类库中的任何集合都可以使用“for each” 循环。
5. 在 Java SE 8 中， 甚至不用写循环。可以调用 forEachRemaining 方法并提供一lambda表达式（它会处理一个元素）。 将对迭代器的每一个元素调用这个 lambda 表达式，直到再没有元素为止。
6. 元素被访问的顺序取决于集合类型。
   - 如果对 ArrayList 进行迭代， 迭代器将从索引 0 开始， 每迭代一次， 索引值加 1
   -  然而， 如果访问 HashSet 中的元素， 每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。

```java
		Collection<String> c={};
		Iterator<String> iter=c.iterator();  //返回一个用于访问集合中每个元素的迭代器。
		while(iter.hasNext()){
			String element=iter.next();
			System.out.println(element);
		}
		//用“ foreach” 循环可以更加简练地表示同样的循环操作：
		//编译器简单地将“ foreach” 循环翻译为带有迭代器的循环。
		for (String e:c){
			System.out.println(e);
		}
		//在 Java SE 8 中可以调用 forEachRemaining 方法
		iter.forEachRemaining(e->System.out.println(e));

		iter.next();  //越过这个元素
		iter.remove();  //删除
		iter.next();  //越过这个元素
		iter.remove();  //删除
```

1.  C++ 的标准模版库， 迭代器是根据数组索引建模的。但是，Java 迭代器并不是这样操作的。查找操作与位置变更是紧密相连的。查找一个元素的唯一方法是调用 next, 而在执行查找操作的同时， 迭代器的位置随之向前移动。
2. 因此， 应该将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用
3. 有一个有用的推论。 可以将Iterator.next 与 InputStream.read 看作为等效的。从数据流中读取一个字节， 就会自动地“ 消耗掉” 这个字节。 下一次调用 read 将会消耗并返回输入的下一个字节。 用同样的方式， 反复地调用 next 就可以读取集合中所有元素。
4. terator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。在大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。然而， 如果想要删除指定位置上的元素， 仍然需要越过这个元素。
5. 对 next 方法和 remove 方法的调用具有互相依赖性。如果调用 remove 之前没有调用 next 将是不合法的。 如果这样做， 将会抛出一个 IllegalStateException 异常。
6. 如果想删除两个相邻的元素， 必须先调用 next 越过将要删除的元素。

### 1.4  泛型实用方法

1. 由于 Collection 与 Iterator 都是泛型接口， 可以编写操作任何集合类型的实用方法。

   ```java
   	public static <E> boolean contains(Collection<E> c,Object obj){
   		//检测任意集合是否包含指定元素的泛型方法
   		for (E element:c){
   			if (element.equals(obj)) return true;
   		}
   		return false;
   	}
   ```

2. Collection 接口声明了很多有用的方法，所有的实现类都必须提供这些方法。列举了其中的一部分:

   ```java
   int size()  //返回当前存储在集合中的元素个数。
   boolean isEmpty()  //如果集合中没有元素， 返回 true。
   boolean contains(Object obj)  //如果集合中包含了一个与 obj 相等的对象， 返回 true。
   boolean containsAll(Collection<?> other)  //如果这个集合包含 other 集合中的所有元素， 返回 trueo
   boolean equals(Object other)  //
   boolean addAll(Collection<? extends E> other)  //将 other 集合中的所有元素添加到这个集合。 如果由于这个调用改变了集合， 返回 true。
   boolean remove(Object obj)  //从这个集合中删除等于 obj 的对象。 如果有匹配的对象被删除， 返回 true。
   boolean removeAll(Collection<?> other)  //从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true。
   default boolean removeIf(Predicate<? super E> filter)  //从这个集合删除 filter 返回 true 的所有元素。 如果由于这个调用改变了集合， 则返回 true。
   void clear()  //从这个集合中删除所有的元素。
   boolean retainAll(Collection<?> other)  //从这个集合中删除所有与 other 集合中的元素不同的元素。 如果由于这个调用改变了集合， 返回 true。
   Object[] toArray()  //返回这个集合的对象数组。
   <T> T[] toArray(T[] arrayToFill)  /*返回这个集合的对象数组。 如果 arrayToFill 足够大， 就将集合中的元素填入这个数组
   中。剩余空间填补 null ; 否则， 分配一个新数组， 其成员类型与 arrayToFill 的成员类
   型相同， 其长度等于集合的大小， 并填充集合元素。*/
   ```

3.  Java 类库提供了一个类 AbstractCollection，它将基础方法 size 和 iterator 抽象化了.一个具体的集合类可以扩展 AbstractCollection 类

### 1.5  集合框架中的接口

Java 集合框架为不同类型的集合定义了大量接口，

![](E:\pogject\javalearn\学习笔记\img\集合框架的接口.png)

1. 集合有两个基本接口：Collection 和 Map。 

2. 在集合中插人元素：boolean add(E element)   。不过，由于映射包含键 / 值对，所以要用 put 方法来插人：V put(K key, V value)

3. 要从集合读取元素， 可以用迭代器访问元素。不过， 从映射中读取值则要使用 get 方法：V get(K key)

4. List 是一个有序集合 （ or办 元 素 会 增 加 到 容 器 中 的 特 定 位 置。 可 以 采 用两种方式访问元素： 使用迭代器访问， 或者使用一个整数索引来访问。后一种方法称为随机访问（random access), 因为这样可以按任意顺序访问元素。与之不同， 使用迭代器访问时，必须顺序地访问元素。

5. List 接口定义了多个用于随机访问的方法：

   void add(int index, E element)
   void remove(int index)
   E get(int index)
   E set(int index, E element)

6. Listlterator 接口是 Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：

   void add(E element)

7. 实际中有两种有序集合，其性能开销有很大差异。

   - 由数组支持的有序集合可以快速地随机访问，因此适合使用 List 方法并提供一个整数索引来访问。
   - 与之不同， 链表尽管也是有序的， 但是随机访问很慢， 所以最好使用迭代器来遍历。 

8. Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集（set) 的 add 方法不允许增加重复的元素。要适当地定义集的 equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。

9. 既然方法签名是一样的， 为什么还要建立一个单独的接口呢？ 从概念上讲， 并不是所有集合都是集。建立一个 Set 接口可以让程序员编写只接受集的方法。

10. SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。

11. Java SE 6 引人了接口 NavigableSet 和 NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法。TreeSet 和 TreeMap 类实现了这些接口。

12. 为了避免对链表完成随机访问操作， Java SE 1.4 引入了一个标记接口 RandomAccess。这个接口不包含任何方法， 不过可以用它来测试一个特定的集合是否支持高效的随机访问：

    ```java
    if (c instanceof RandomAccess){
    	use random access algorithm
    }else{
    	usesequential access algorithm
    }
    ```

    

## 2  具体的集合

![Java 库中的具体集合](E:\pogject\javalearn\学习笔记\img\Java 库中的具体集合.png)

除了以 Map 结尾的类之外， 其他类都实现了 Collection 接口，而以 Map 结尾的类实现了 Map 接口。

### 2.1  链 表

1. 数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。在数组中间的位置上插入一个元素也是如此。
2. 尽管数组在连续的存储位置上存放对象引用， 但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。
3. 在 Java 程序设计语言中， 所有链表实际上都是双向链接的(doubly linked)—即每个结点还存放着指向前驱结点的引用。
4. 从链表中间删除一个元素是一个很轻松的操作， 即需要更新被删除元素附近的链接。

```java
public class TestBase6{
	public static void main(String[] args) {
		List<String> staff=new LinkedList<>();
		staff.add("mane");
		staff.add("Arnold");
		staff.add("Alison");

		Iterator<String> iter=staff.iterator();
		for (String e:staff) System.out.print(e+"\t");
		String first=iter.next();  //访问第一个元素
		String second=iter.next();  //访问第二个元素
		iter.remove();  //移除上一次访问的元素
		System.out.println();
		for (String e:staff) System.out.print(e+"\t");
		System.out.println();
		
	}
}
/*
------Output------
mane	Arnold	Alison	
mane	Alison	
*/
```

1. 链 表 与 泛 型 集 合 之 间 有 一 个 重 要 的 区 别。 链 表 是 一 个 有 序 集 合（orderedcollection), 每个对象的位置十分重要。

2.  LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。 由于迭代器是描述集合中位置的， 所以这种依赖于位置的 add 方法将由迭代器负责。 只有对自然有序的集合使用迭代器添加元素才有实际意义。

3. 集合类库提供了子接口 Listlterator, 其 中 包 含 add 方 法。与 Collection.add 不同， 这个方法不返回 boolean 类型的值， 它假定添加操作总会改变链表。

4. 另外， Listlterator 接口有两个方法， 可以用来反向遍历链表。与 next 方法一样， previous 方法返回越过的对象。

   E previous()
   boolean hasPreviousO

5. Add 方法在迭代器位置之前添加一个新对象。

   ```java
   		List<String> staff=new LinkedList<>();
   		staff.add("mane");
   		staff.add("Arnold");
   		staff.add("Alison");
   
   		for (String e:staff) System.out.print(e+"\t");
   		System.out.println();
   		ListIterator<String> iter2=staff.listIterator();
   		iter2.next();  //跳过一个元素
   		iter2.add("kloop");  //添加
   		for (String e:staff) System.out.print(e+"\t");
   		System.out.println();
   /*
   ------Output------
   mane	Arnold	Alison	
   mane	kloop	Arnold	Alison	
   */
   ```

6. 如果多次调用 add 方法， 将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。

7. 当用一个刚刚由 Iterator 方法返回， 并且指向链表表头的迭代器调用 add 操作时， 新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时（即 hasNext 返回 false),添加的元素将变成列表的新表尾。

8. 如果链表有 n 个元素，有 n+1 个位置可以添加新元素。这些位置与迭代器的 n+1 个可能的位置相对应。 

9. 在调用 next 之后， remove 方法确实与 BACKSPACE 键一样删除了迭代器左侧的元素。但是， 如果调用 previous 就会将右侧的元素删除掉， 并且不能连续调用两次remove。

10. add 方法只依赖于迭代器的位置， 而 remove 方法依赖于迭代器的状态。

11. set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。

    ```java
    		List<String> staff=new LinkedList<>();
    		staff.add("mane");
    		staff.add("Arnold");
    		staff.add("Alison");
    
    		for (String e:staff) System.out.print(e+"\t");
    		System.out.println();
    		ListIterator<String> iter2=staff.listIterator();
    		String first=iter2.next();  //第一个元素
    		iter2.set("Robson");  //设置第一个元素的值
    		for (String e:staff) System.out.print(e+"\t");
    		System.out.println();
    /*
    mane	Arnold	Alison	
    Robson	Arnold	Alison	
    */
    		String obj=staff.get(2);
    		System.out.println(obj);  //Alison
    //
    ```

    1. 可以想象， 如果在某个迭代器修改集合时， 另一个迭代器对其进行遍历， 一定会出现混乱的状况。

       例如，一个迭代器指向另一个迭代器刚刚删除的元素前面， 现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。 如果迭代器发现它的集合被另一个迭代器修改了， 或是被该集合自身的方法修改了， 就会抛出一个ConcurrentModificationException 异常。 

    2. 为了避免发生并发修改的异常，请遵循下述简单规则：**可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表**。另外，**再单独附加一个既能读又能写的迭代器。**

    3. 集合可以跟踪改写操作（诸如添加或删除元素）的次数。**每个迭代器都维护一个独立的计数值**。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。 如果不一致， 抛出一个 ConcurrentModificationException 异常。

    4. 对于并发修改列表的检测肴一个奇怪的例外。链表只负责跟踪对列表的结构性修改， 例如， 添加元素、 删除元素。set 方法不被视为结构性修改。 可以将多个迭代器附加给一个链表， 所有的迭代器都调用 set 方法对现有结点的内容进行修改。

    5. Collection 接口中声明了许多用于对链表操作的有用方法。其中大部分方法都是在 LinkedList 类的超类 AbstractCollection 中实现的。

    6. 链表不支持快速地随机访问。 如果要查看链表中第《个元素，就必须从头开始， 越过个元素。没有捷径可走。

    7. 尽管如此， LinkedList 类还是提供了一个用来访问某个特定元素的 **get 方法**.这个方法的效率并不太高。 如果发现自己正在使用这个方法，说明有可能对于所要解决的问题使用了错误的数据结构。get 方法做了微小的优化： 如果索引大于 size() / 2 就从列表尾端开始搜索元素。

    8. 每次査找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。

    9. 列表迭代器接口还有一个方法，可以告之当前位置的索引。实际上，从概念上讲， 由于Java 迭代器指向两个元素之间的位置， 所以可以同时产生两个索引：

       - nextlndex 方法返回下一次调用 next 方法时返回元素的整数索引；
       - previouslndex 方法返回下一次调用 previous 方法时返回元素的整数索引。当然， 这个索引只比 nextlndex 返回的索引值小 1。
       - 这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。

    10. 如果有一个整数索引 n,list.listlterator(n) 将返回一个迭代器， 这个迭代器指向索引为 n 的元素前面的位置。也就是说， 调用 next 与调用 list.get(n) 会产生同一个元素， 只是获得这个迭代器的效率比较低。
    
    11. 如果链表中只有很少几个元素， 就完全没有必要为 get 方法和 set 方法的开销而烦恼。使用链表的唯一理由是尽可能地减少在列表中间插人或删除元素所付出的代价。 如果列表只有少数几个元素， 就完全可以使用 ArrayList。
    
    12. 建议避免使用以整数索引表示链表中位置的所有方法。 如果需要对集合进行随机访问， 就使用数组或 ArrayList, 而不要使用链表。

```java
public class TestBase6{
	public static void main(String[] args) {
		List<String> staff=new LinkedList<>();
		staff.add("mane");
		staff.add("Arnold");
		staff.add("Alison");

		List<String> sports=new LinkedList<>();
		sports.add("Robson");
		sports.add("Origin");
		sports.add("Hendson");
		sports.add("Milern");

		System.out.println("初始staff:"+staff);
		System.out.println("初始sport:"+sports);

		ListIterator<String> iter1=staff.listIterator();  //返回一个列表迭代器， 以便用来访问列表中的元素。
		Iterator<String> iter2=sports.iterator();
		//合并
		while (iter2.hasNext()) {
			if (iter1.hasNext()) iter1.next();
			iter1.add(iter2.next());
		}
		System.out.println("合并sport到staff:"+staff);

		iter2=sports.iterator();
		while (iter2.hasNext()){
			iter2.next();  //跳过一个元素
			if (iter2.hasNext()) {
				iter2.next();
				iter2.remove();  //隔一个删一个
			}
		}
		System.out.println("从sport中隔一个删一个："+sports);

		staff.removeAll(sports);
		System.out.println("删除在staff中的sport:"+staff);
	}
}
/*
------Output------
初始staff:[mane, Arnold, Alison]
初始sport:[Robson, Origin, Hendson, Milern]
合并sport到staff:[mane, Robson, Arnold, Origin, Alison, Hendson, Milern]
从sport中隔一个删一个：[Robson, Hendson]
删除在staff中的sport:[mane, Arnold, Origin, Alison, Milern]
*/
```

```

```

### 2.2  数组列表

1. 集合类库提供了一种大家熟悉的 ArrayList 类， 这个类也实现了 List 接口。ArrayList 封装了一个动态再分配的对象数组。
2. Vector 类的所有方法都是同步的。 可以由两个线程安全地访问一个 Vector 对象。但是， 如果由一个线程访问 Vector, 代码要在同步操作上耗费大量的时间。这种情况还是很常见的。 而 ArrayList 方法不是同步的，因此， 建议在不需要同步时使用 ArrayList, 而不要使用 Vector。

### 2.3  散列集

1. 链表和数组可以按照人们的意愿排列元素的次序。但是， 如果想要査看某个指定的元素， 却又忘记了它的位置， 就需要访问所有元素， 直到找到为止。如果集合中包含的元素很多， 将会消耗很多时间。 

2. 如果不在意元素的顺序， 可以有几种能够快速査找元素的数据结构。其缺点是无法控制元素出现的次序。 它们将按照有利于其操作目的的原则组织数据。

3. 有一种众所周知的数据结构， 可以快速地査找所需要的对象， 这就是散列表（hash)。

4.  散列表为每个对象计算一个整数， 称为散列码（hashcode)。散列码是由对象的实例域产生的一个整数。 更准确地说， 具有不同数据域的对象将产生不同的散列码。 

5. 如果自定义类，就要负责实现这个类的 hashCode方法。注意，自己实现的 hashCode方法应该与 equals 方法兼容，即如果 a_equals(b) 为 true, a 与 b 必须具有相同的散列码。

6. 最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。

7. 在 Java 中， 散列表用链表数组实现。每个列表被称为桶 （ bucket)。要想査找表中对象的位置， 就要先计算它的散列码， 然后与桶的总数取余， 所得到的结果就是保存这个元素的桶的索引。

   例如， 如果某个对象的散列码为 76268, 并且有 128 个桶， 对象应该保存在第 108 号桶中（76268除以 128 余 108 )。 或许会很幸运， 在这个桶中没有其他元素， 此时将元素直接插人到桶中就可以了。

8. 当然， 有时候会遇到桶被占满的情况， 这也是不可避免的。这种现象被称为散列冲突（ hash collision) 。 这时， 需要用新对象与桶中的所有对象进行比较， 査看这个对象是否已经存在。如果散列码是合理且随机分布的， 桶的数目也足够大， 需要比较的次数就会很少。

9. 在 JavaSE 8 中， 桶满时会从链表变为平衡二叉树。如果选择的散列函数不当， 会产生很多冲突， 或者如果有恶意代码试图在散列表中填充多个有相同散列码的值， 这样就能提高性能。

10. 如果想更多地控制散列表的运行性能， 就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。 如果要插入到散列表中的元素太多， 就会增加冲突的可能性， 降低运行性能。

11. 如果大致知道最终会有多少个元素要插人到散列表中， 就可以设置桶数。通常， 将桶数设置为预计元素个数的 75% ~ 150%。有些研究人员认为：尽管还没有确凿的证据， 但最好将桶数设置为一个素数， 以防键的集聚。标准类库使用的桶数是 2 的幂， 默认值为 16 (为表大小提供的任何值都将被自动地转换为 2 的下一个幂)。

12. 如果散列表太满， 就需要再散列 （rehashed)。 如果要对散列表再散列， 就需要创建一个桶数更多的表，并将所有元素插入到这个新表中.，然后丢弃原来的表。 

13. 装填因子（ load factor) 决定何时对散列表进行再散列。 例如， 如果装填因子为 0.75 (默认值)， 而表中超过 75% 的位置已经填人元素， 这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说， 装填因子为0.75 是比较合理的。

14. 散列表可以用于实现几个重要的数据结构。 其中最简单的是 set 类型。set 是没有重复元素的元素集合。set 的 add 方法首先在集中查找要添加的对象， 如果不存在，就将这个对象添加进去。

15. Java 集合类库提供了一个 HashSet 类，它实现了基于散列表的集。可以用 add 方法添加元素。contains 方法已经被重新定义， 用来快速地查看是否某个元素已经出现在集中。它只在某个桶中査找元素，而不必查看集合中的所有元素。

16. 散列集迭代器将依次访问所有的桶。 由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用 HashSet。

17. 在更改集中的元素时要格外小心。 如果元素的散列码发生了改变， 元素在数据结构中的位置也会发生变化。

```java
import java.util.*;

public class TestBase7{
	public static void main(String[] args) {
		Set<String> words=new HashSet<>();  //构造一个空散列表。
		long totalTime=0;

		try (Scanner in=new Scanner(System.in)){
			while (in.hasNext()){
				String word=in.next();
				long callTime=System.currentTimeMillis();
				words.add(word);
				callTime=System.currentTimeMillis()-callTime;
				totalTime+=callTime;
			}
		}
		Iterator<String> iter=words.iterator();
		for (int i=1;i<=20 && iter.hasNext(); i++) {
			if (i%5==0) {
				System.out.println();
			}
			System.out.print(iter.next()+"\t");
		}
		System.out.println("...");
		System.out.println(words.size()+" distinct words. "+totalTime+" milliseconds");
	}
}
/*读取输人的所有单词， 并且将它们添加到散列集中。然后遍历散列集中的不
同单词，最后打印出单词的数量 ,单词以随机的顺序出现。
*/
//java TestBase7 < a.txt
/*
$ java TestBase7 < a.txt
big     explosive       data    advanced
high-speed      serve   issues  sequencing      that
appeared        problem reality,        huge    those
which   development     computing(HPC)along     in      need
impact  ...
77 distinct words. 0 milliseconds
*/

```

```java
java.util.HashSet<E>
	HashSet( )
   // 构造一个空散列表。
    • HashSet( Collection<? extends E> elements )
   // 构造一个散列集， 并将集合中的所有元素添加到这个散列集中。
    • HashSet( int initialCapacity)
   // 构造一个空的具有指定容量（桶数）的散列集。
    • HashSet(int initialCapacity , float loadFactor )
	//构造一个具有指定容量和装填因子（一个 0.0 ~ 1.0 之间的数值， 确定散列表填充的百分比， 当大于这个百分比时， 散列表进行再散列）的空散列集。
java.Iang.Object l.O
    • int hashCode( )
    //返回这个对象的散列码。 散列码可以是任何整数， 包括正数或负数。equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCodeO 必须等于 y.hashCodeO。	
```

### 2.4  树集

1. TreeSet 类与散列集十分类似， 不过， 它比散列集有所改进。 树集是一个有序集合( sorted collection) .可以以任意顺序将元素插入到集合中。在对集合进行遍历时， 每个值将自动地按照排序后的顺序呈现。

   ```java
   		SortedSet<String> sorter=new TreeSet<>();
   		sorter.add("mane");
   		sorter.add("Arnold");
   		sorter.add("Alison");
   		for (String s:sorter) System.out.print(s+"\t");
   		System.out.println();
   	//Alison	Arnold	mane	
   ```

2. 正如 TreeSet 类名所示， 排序是用树结构完成的（当前实现使用的是红黑树（red-black tree )。每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

3. 将一个元素添加到树中要比添加到散列表中慢，但是， 与检查数组或链表中的重复元素相比还是快很多。

4.  要使用树集， 必须能够比较元素。 这些元素必须实现 Comparable 接口，或者构造集时必须提供一个 Comparator 

5. 是否总是应该用树集取代散列集。毕竟， 添加一个元素所花费的时间看上去并不很长，而且元素是自动排序的。到底应该怎样做将取决于所要收
   集的数据。

   - 如果不需要对数据进行排序， 就没有必要付出排序的开销。
   - 更重要的是， 对于某些数据来说， 对其排序要比散列函数更加困难。
   -  散列函数只是将对象适当地打乱存放， 而比较却要精确地判别每个对象。

6. 树的排序必须是全序。 也就是说， 任意两个元素必须是可比的， 并且只有在两个元素相等时结果才为 0。 

7.  从 JavaSE 6 起， TreeSet 类实现了 NavigableSet 接口。 这个接口增加了几个便于定位元素以及反向遍历的方法。

```java
import java.util.*;

class Item implements Comparable<Item>{
	private String description;
	private int partNumber;

	public Item(String d,int p){
		description=d;
		partNumber=p;
	}

	public String getDescription(){
		return description;
	}
	public String toString(){
		return "[description="+description+", partNumber="+partNumber+"]";
	}
	public boolean equals(Object otherObject){
		if (this==otherObject) return true;
		if (otherObject==null) return false;
		if (getClass()!=otherObject.getClass()) return false;
		Item other=(Item) otherObject;
		return Objects.equals(description,other.description) && partNumber==other.partNumber;
	}
	public int hashCode(){
		return Objects.hash(description,partNumber);
	}
	public int compareTo(Item other){
		int diff=Integer.compare(partNumber,other.partNumber);
		return diff!=0 ? diff : description.compareTo(other.description);
	}
}

public class TestBase7{
	public static void main(String[] args) {
		SortedSet<Item> sorter=new TreeSet<>();  //构造一个空树集。
		sorter.add(new Item("mane",10));
		sorter.add(new Item("Arnold",66));
		sorter.add(new Item("Alison",1));
		System.out.println(sorter);

		NavigableSet<Item> sortByDescription = new TreeSet<>(Comparator.comparing(Item::getDescription));
		//返回用于对元素进行排序的比较器。 如果元素用 Comparable 接口的 compareTo方法进行比较则返回 null。
		sortByDescription.addAll(sorter);
		System.out.println(sortByDescription);

	}
}
/*
------Output------
[[description=Alison, partNumber=1], [description=mane, partNumber=10], [description=Arnold, partNumber=66]]
[[description=Alison, partNumber=1], [description=Arnold, partNumber=66], [description=mane, partNumber=10]]
*/

```

### 2.5  队列与双端队列

