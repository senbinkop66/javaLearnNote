# 集合

## 1  Java 集合框架

### 1.1  将集合的接口与实现分离

1. 与现代的数据结构类库的常见情况一样， Java 集合类库也将接口 （ interface) 与 实 现(implementation) 分离。

2. 队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列。 队列通常有两种实现方式： 一种是使用循环数组； 另一种是使用链表 。

3. 如果需要一个循环数组队列， 就可以使用 ArrayDeque 类。 如果需要一个链表队列， 就直接使用 LinkedList类， 这个类实现了 Queue 接口。

4. 当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此， 只有在构建集合对象时，使用具体的类才有意义。可以使用接口类型存放集合的引用。

   ```java
   		
   		Queue<Person> persons=new CircularArrayQueue<>(100);
   		persons.add(new Person("mane"));
   		//
   		Queue<Person> persons=new LinkedListQueue<>(100);
   		persons.add(new Person("mane"));
   ```

5. 利用这种方式，一旦改变了想法， 可以轻松地使用另外一种不同的实现。只需要对程序的一个地方做出修改， 即调用构造器的地方。 如果觉得 LinkedListQueue 是个更好的选择，就将代码修改。

6. 循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。

### 1.2  Collection 接口

1. 在 Java 类库中，集合类的基本接口是 Collection 接口。这个接口有两个基本方法

   ```java
   public interface Collection<E>{
   	boolean add(E element);  //将一个元素添加到集合中。如果由于这个调用改变了集合，返回 true。
   	Iterator<E> iterator();
   	...;
   }
   ```

   除了这两个方法之外，还有几个方法，

   - add 方法用于向集合中添加元素。 如果添加元素确实改变了集合就返回 true, 如果集合没有发生变化就返回 false。
   - iterator 方法用于返回一个实现了 Iterator 接口的对象。 可以使用这个迭代器对象依次访问集合中的元素。

### 1.3  迭代器

Iterator 接口包含 4 个方法：

```java
public interface Iterator<E>{
	E next();  //返回将要访问的下一个对象。 如果已经到达了集合的尾部， 将拋出一个 NoSuchElementException。
	boolean hasNext();  //如果存在可访问的元素， 返回 true。
	void remove();  //删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化， 这个方法将抛出一个 IllegalStateException。
	default void forEachRemaining(Consumer<? super E> action);
}
```

1. 通过反复调用 next 方法，可以逐个访问集合中的每个元素。但是， 如果到达了集合的末尾，next 方法将抛出一个 NoSuchElementException。 
2. 因此，需要在调用 next 之前调用 hasNext方法。如果迭代器对象还有多个供访问的元素， 这个方法就返回 true。
3. 如果想要査看集合中的所有元素，就请求一个迭代器，并在 hasNext 返回 true 时反复地调用 next 方法。
4. Collection 接口扩展了 Iterable 接口。因此， 对于标准类库中的任何集合都可以使用“for each” 循环。
5. 在 Java SE 8 中， 甚至不用写循环。可以调用 forEachRemaining 方法并提供一lambda表达式（它会处理一个元素）。 将对迭代器的每一个元素调用这个 lambda 表达式，直到再没有元素为止。
6. 元素被访问的顺序取决于集合类型。
   - 如果对 ArrayList 进行迭代， 迭代器将从索引 0 开始， 每迭代一次， 索引值加 1
   -  然而， 如果访问 HashSet 中的元素， 每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。

```java
		Collection<String> c={};
		Iterator<String> iter=c.iterator();  //返回一个用于访问集合中每个元素的迭代器。
		while(iter.hasNext()){
			String element=iter.next();
			System.out.println(element);
		}
		//用“ foreach” 循环可以更加简练地表示同样的循环操作：
		//编译器简单地将“ foreach” 循环翻译为带有迭代器的循环。
		for (String e:c){
			System.out.println(e);
		}
		//在 Java SE 8 中可以调用 forEachRemaining 方法
		iter.forEachRemaining(e->System.out.println(e));

		iter.next();  //越过这个元素
		iter.remove();  //删除
		iter.next();  //越过这个元素
		iter.remove();  //删除
```

1.  C++ 的标准模版库， 迭代器是根据数组索引建模的。但是，Java 迭代器并不是这样操作的。查找操作与位置变更是紧密相连的。查找一个元素的唯一方法是调用 next, 而在执行查找操作的同时， 迭代器的位置随之向前移动。
2. 因此， 应该将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用
3. 有一个有用的推论。 可以将Iterator.next 与 InputStream.read 看作为等效的。从数据流中读取一个字节， 就会自动地“ 消耗掉” 这个字节。 下一次调用 read 将会消耗并返回输入的下一个字节。 用同样的方式， 反复地调用 next 就可以读取集合中所有元素。
4. terator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。在大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。然而， 如果想要删除指定位置上的元素， 仍然需要越过这个元素。
5. 对 next 方法和 remove 方法的调用具有互相依赖性。如果调用 remove 之前没有调用 next 将是不合法的。 如果这样做， 将会抛出一个 IllegalStateException 异常。
6. 如果想删除两个相邻的元素， 必须先调用 next 越过将要删除的元素。

### 1.4  泛型实用方法

1. 由于 Collection 与 Iterator 都是泛型接口， 可以编写操作任何集合类型的实用方法。

   ```java
   	public static <E> boolean contains(Collection<E> c,Object obj){
   		//检测任意集合是否包含指定元素的泛型方法
   		for (E element:c){
   			if (element.equals(obj)) return true;
   		}
   		return false;
   	}
   ```

2. Collection 接口声明了很多有用的方法，所有的实现类都必须提供这些方法。列举了其中的一部分:

   ```java
   int size()  //返回当前存储在集合中的元素个数。
   boolean isEmpty()  //如果集合中没有元素， 返回 true。
   boolean contains(Object obj)  //如果集合中包含了一个与 obj 相等的对象， 返回 true。
   boolean containsAll(Collection<?> other)  //如果这个集合包含 other 集合中的所有元素， 返回 trueo
   boolean equals(Object other)  //
   boolean addAll(Collection<? extends E> other)  //将 other 集合中的所有元素添加到这个集合。 如果由于这个调用改变了集合， 返回 true。
   boolean remove(Object obj)  //从这个集合中删除等于 obj 的对象。 如果有匹配的对象被删除， 返回 true。
   boolean removeAll(Collection<?> other)  //从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true。
   default boolean removeIf(Predicate<? super E> filter)  //从这个集合删除 filter 返回 true 的所有元素。 如果由于这个调用改变了集合， 则返回 true。
   void clear()  //从这个集合中删除所有的元素。
   boolean retainAll(Collection<?> other)  //从这个集合中删除所有与 other 集合中的元素不同的元素。 如果由于这个调用改变了集合， 返回 true。
   Object[] toArray()  //返回这个集合的对象数组。
   <T> T[] toArray(T[] arrayToFill)  /*返回这个集合的对象数组。 如果 arrayToFill 足够大， 就将集合中的元素填入这个数组
   中。剩余空间填补 null ; 否则， 分配一个新数组， 其成员类型与 arrayToFill 的成员类
   型相同， 其长度等于集合的大小， 并填充集合元素。*/
   ```

3.  Java 类库提供了一个类 AbstractCollection，它将基础方法 size 和 iterator 抽象化了.一个具体的集合类可以扩展 AbstractCollection 类

### 1.5  集合框架中的接口

Java 集合框架为不同类型的集合定义了大量接口，

![](E:\pogject\javalearn\学习笔记\img\集合框架的接口.png)

1. 集合有两个基本接口：Collection 和 Map。 

2. 在集合中插人元素：boolean add(E element)   。不过，由于映射包含键 / 值对，所以要用 put 方法来插人：V put(K key, V value)

3. 要从集合读取元素， 可以用迭代器访问元素。不过， 从映射中读取值则要使用 get 方法：V get(K key)

4. List 是一个有序集合 （ or办 元 素 会 增 加 到 容 器 中 的 特 定 位 置。 可 以 采 用两种方式访问元素： 使用迭代器访问， 或者使用一个整数索引来访问。后一种方法称为随机访问（random access), 因为这样可以按任意顺序访问元素。与之不同， 使用迭代器访问时，必须顺序地访问元素。

5. List 接口定义了多个用于随机访问的方法：

   void add(int index, E element)
   void remove(int index)
   E get(int index)
   E set(int index, E element)

6. Listlterator 接口是 Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：

   void add(E element)

7. 实际中有两种有序集合，其性能开销有很大差异。

   - 由数组支持的有序集合可以快速地随机访问，因此适合使用 List 方法并提供一个整数索引来访问。
   - 与之不同， 链表尽管也是有序的， 但是随机访问很慢， 所以最好使用迭代器来遍历。 

8. Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集（set) 的 add 方法不允许增加重复的元素。要适当地定义集的 equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。

9. 既然方法签名是一样的， 为什么还要建立一个单独的接口呢？ 从概念上讲， 并不是所有集合都是集。建立一个 Set 接口可以让程序员编写只接受集的方法。

10. SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。

11. Java SE 6 引人了接口 NavigableSet 和 NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法。TreeSet 和 TreeMap 类实现了这些接口。

12. 为了避免对链表完成随机访问操作， Java SE 1.4 引入了一个标记接口 RandomAccess。这个接口不包含任何方法， 不过可以用它来测试一个特定的集合是否支持高效的随机访问：

    ```java
    if (c instanceof RandomAccess){
    	use random access algorithm
    }else{
    	usesequential access algorithm
    }
    ```

    

## 2  具体的集合

![Java 库中的具体集合](E:\pogject\javalearn\学习笔记\img\Java 库中的具体集合.png)

除了以 Map 结尾的类之外， 其他类都实现了 Collection 接口，而以 Map 结尾的类实现了 Map 接口。

### 2.1  链 表

1. 数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。在数组中间的位置上插入一个元素也是如此。
2. 尽管数组在连续的存储位置上存放对象引用， 但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。
3. 在 Java 程序设计语言中， 所有链表实际上都是双向链接的(doubly linked)—即每个结点还存放着指向前驱结点的引用。
4. 从链表中间删除一个元素是一个很轻松的操作， 即需要更新被删除元素附近的链接。

```java
public class TestBase6{
	public static void main(String[] args) {
		List<String> staff=new LinkedList<>();
		staff.add("mane");
		staff.add("Arnold");
		staff.add("Alison");

		Iterator<String> iter=staff.iterator();
		for (String e:staff) System.out.print(e+"\t");
		String first=iter.next();  //访问第一个元素
		String second=iter.next();  //访问第二个元素
		iter.remove();  //移除上一次访问的元素
		System.out.println();
		for (String e:staff) System.out.print(e+"\t");
		System.out.println();
		
	}
}
/*
------Output------
mane	Arnold	Alison	
mane	Alison	
*/
```

1. 链 表 与 泛 型 集 合 之 间 有 一 个 重 要 的 区 别。 链 表 是 一 个 有 序 集 合（orderedcollection), 每个对象的位置十分重要。

2.  LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。 由于迭代器是描述集合中位置的， 所以这种依赖于位置的 add 方法将由迭代器负责。 只有对自然有序的集合使用迭代器添加元素才有实际意义。

3. 集合类库提供了子接口 Listlterator, 其 中 包 含 add 方 法。与 Collection.add 不同， 这个方法不返回 boolean 类型的值， 它假定添加操作总会改变链表。

4. 另外， Listlterator 接口有两个方法， 可以用来反向遍历链表。与 next 方法一样， previous 方法返回越过的对象。

   E previous()
   boolean hasPreviousO

5. Add 方法在迭代器位置之前添加一个新对象。

   ```java
   		List<String> staff=new LinkedList<>();
   		staff.add("mane");
   		staff.add("Arnold");
   		staff.add("Alison");
   
   		for (String e:staff) System.out.print(e+"\t");
   		System.out.println();
   		ListIterator<String> iter2=staff.listIterator();
   		iter2.next();  //跳过一个元素
   		iter2.add("kloop");  //添加
   		for (String e:staff) System.out.print(e+"\t");
   		System.out.println();
   /*
   ------Output------
   mane	Arnold	Alison	
   mane	kloop	Arnold	Alison	
   */
   ```

6. 如果多次调用 add 方法， 将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。

7. 当用一个刚刚由 Iterator 方法返回， 并且指向链表表头的迭代器调用 add 操作时， 新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时（即 hasNext 返回 false),添加的元素将变成列表的新表尾。

8. 如果链表有 n 个元素，有 n+1 个位置可以添加新元素。这些位置与迭代器的 n+1 个可能的位置相对应。 

9. 在调用 next 之后， remove 方法确实与 BACKSPACE 键一样删除了迭代器左侧的元素。但是， 如果调用 previous 就会将右侧的元素删除掉， 并且不能连续调用两次remove。

10. add 方法只依赖于迭代器的位置， 而 remove 方法依赖于迭代器的状态。

11. set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。

    ```java
    		List<String> staff=new LinkedList<>();
    		staff.add("mane");
    		staff.add("Arnold");
    		staff.add("Alison");
    
    		for (String e:staff) System.out.print(e+"\t");
    		System.out.println();
    		ListIterator<String> iter2=staff.listIterator();
    		String first=iter2.next();  //第一个元素
    		iter2.set("Robson");  //设置第一个元素的值
    		for (String e:staff) System.out.print(e+"\t");
    		System.out.println();
    /*
    mane	Arnold	Alison	
    Robson	Arnold	Alison	
    */
    		String obj=staff.get(2);
    		System.out.println(obj);  //Alison
    //
    ```

    1. 可以想象， 如果在某个迭代器修改集合时， 另一个迭代器对其进行遍历， 一定会出现混乱的状况。

       例如，一个迭代器指向另一个迭代器刚刚删除的元素前面， 现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。 如果迭代器发现它的集合被另一个迭代器修改了， 或是被该集合自身的方法修改了， 就会抛出一个ConcurrentModificationException 异常。 

    2. 为了避免发生并发修改的异常，请遵循下述简单规则：**可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表**。另外，**再单独附加一个既能读又能写的迭代器。**

    3. 集合可以跟踪改写操作（诸如添加或删除元素）的次数。**每个迭代器都维护一个独立的计数值**。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。 如果不一致， 抛出一个 ConcurrentModificationException 异常。

    4. 对于并发修改列表的检测肴一个奇怪的例外。链表只负责跟踪对列表的结构性修改， 例如， 添加元素、 删除元素。set 方法不被视为结构性修改。 可以将多个迭代器附加给一个链表， 所有的迭代器都调用 set 方法对现有结点的内容进行修改。

    5. Collection 接口中声明了许多用于对链表操作的有用方法。其中大部分方法都是在 LinkedList 类的超类 AbstractCollection 中实现的。

    6. 链表不支持快速地随机访问。 如果要查看链表中第《个元素，就必须从头开始， 越过个元素。没有捷径可走。

    7. 尽管如此， LinkedList 类还是提供了一个用来访问某个特定元素的 **get 方法**.这个方法的效率并不太高。 如果发现自己正在使用这个方法，说明有可能对于所要解决的问题使用了错误的数据结构。get 方法做了微小的优化： 如果索引大于 size() / 2 就从列表尾端开始搜索元素。

    8. 每次査找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。

    9. 列表迭代器接口还有一个方法，可以告之当前位置的索引。实际上，从概念上讲， 由于Java 迭代器指向两个元素之间的位置， 所以可以同时产生两个索引：

       - nextlndex 方法返回下一次调用 next 方法时返回元素的整数索引；
       - previouslndex 方法返回下一次调用 previous 方法时返回元素的整数索引。当然， 这个索引只比 nextlndex 返回的索引值小 1。
       - 这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。

    10. 如果有一个整数索引 n,list.listlterator(n) 将返回一个迭代器， 这个迭代器指向索引为 n 的元素前面的位置。也就是说， 调用 next 与调用 list.get(n) 会产生同一个元素， 只是获得这个迭代器的效率比较低。
    
    11. 如果链表中只有很少几个元素， 就完全没有必要为 get 方法和 set 方法的开销而烦恼。使用链表的唯一理由是尽可能地减少在列表中间插人或删除元素所付出的代价。 如果列表只有少数几个元素， 就完全可以使用 ArrayList。
    
    12. 建议避免使用以整数索引表示链表中位置的所有方法。 如果需要对集合进行随机访问， 就使用数组或 ArrayList, 而不要使用链表。

```java
public class TestBase6{
	public static void main(String[] args) {
		List<String> staff=new LinkedList<>();
		staff.add("mane");
		staff.add("Arnold");
		staff.add("Alison");

		List<String> sports=new LinkedList<>();
		sports.add("Robson");
		sports.add("Origin");
		sports.add("Hendson");
		sports.add("Milern");

		System.out.println("初始staff:"+staff);
		System.out.println("初始sport:"+sports);

		ListIterator<String> iter1=staff.listIterator();  //返回一个列表迭代器， 以便用来访问列表中的元素。
		Iterator<String> iter2=sports.iterator();
		//合并
		while (iter2.hasNext()) {
			if (iter1.hasNext()) iter1.next();
			iter1.add(iter2.next());
		}
		System.out.println("合并sport到staff:"+staff);

		iter2=sports.iterator();
		while (iter2.hasNext()){
			iter2.next();  //跳过一个元素
			if (iter2.hasNext()) {
				iter2.next();
				iter2.remove();  //隔一个删一个
			}
		}
		System.out.println("从sport中隔一个删一个："+sports);

		staff.removeAll(sports);
		System.out.println("删除在staff中的sport:"+staff);
	}
}
/*
------Output------
初始staff:[mane, Arnold, Alison]
初始sport:[Robson, Origin, Hendson, Milern]
合并sport到staff:[mane, Robson, Arnold, Origin, Alison, Hendson, Milern]
从sport中隔一个删一个：[Robson, Hendson]
删除在staff中的sport:[mane, Arnold, Origin, Alison, Milern]
*/
```

```

```

### 2.2  数组列表

1. 集合类库提供了一种大家熟悉的 ArrayList 类， 这个类也实现了 List 接口。ArrayList 封装了一个动态再分配的对象数组。
2. Vector 类的所有方法都是同步的。 可以由两个线程安全地访问一个 Vector 对象。但是， 如果由一个线程访问 Vector, 代码要在同步操作上耗费大量的时间。这种情况还是很常见的。 而 ArrayList 方法不是同步的，因此， 建议在不需要同步时使用 ArrayList, 而不要使用 Vector。

### 2.3  散列集

1. 链表和数组可以按照人们的意愿排列元素的次序。但是， 如果想要査看某个指定的元素， 却又忘记了它的位置， 就需要访问所有元素， 直到找到为止。如果集合中包含的元素很多， 将会消耗很多时间。 

2. 如果不在意元素的顺序， 可以有几种能够快速査找元素的数据结构。其缺点是无法控制元素出现的次序。 它们将按照有利于其操作目的的原则组织数据。

3. 有一种众所周知的数据结构， 可以快速地査找所需要的对象， 这就是散列表（hash)。

4.  散列表为每个对象计算一个整数， 称为散列码（hashcode)。散列码是由对象的实例域产生的一个整数。 更准确地说， 具有不同数据域的对象将产生不同的散列码。 

5. 如果自定义类，就要负责实现这个类的 hashCode方法。注意，自己实现的 hashCode方法应该与 equals 方法兼容，即如果 a_equals(b) 为 true, a 与 b 必须具有相同的散列码。

6. 最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。

7. 在 Java 中， 散列表用链表数组实现。每个列表被称为桶 （ bucket)。要想査找表中对象的位置， 就要先计算它的散列码， 然后与桶的总数取余， 所得到的结果就是保存这个元素的桶的索引。

   例如， 如果某个对象的散列码为 76268, 并且有 128 个桶， 对象应该保存在第 108 号桶中（76268除以 128 余 108 )。 或许会很幸运， 在这个桶中没有其他元素， 此时将元素直接插人到桶中就可以了。

8. 当然， 有时候会遇到桶被占满的情况， 这也是不可避免的。这种现象被称为散列冲突（ hash collision) 。 这时， 需要用新对象与桶中的所有对象进行比较， 査看这个对象是否已经存在。如果散列码是合理且随机分布的， 桶的数目也足够大， 需要比较的次数就会很少。

9. 在 JavaSE 8 中， 桶满时会从链表变为平衡二叉树。如果选择的散列函数不当， 会产生很多冲突， 或者如果有恶意代码试图在散列表中填充多个有相同散列码的值， 这样就能提高性能。

10. 如果想更多地控制散列表的运行性能， 就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。 如果要插入到散列表中的元素太多， 就会增加冲突的可能性， 降低运行性能。

11. 如果大致知道最终会有多少个元素要插人到散列表中， 就可以设置桶数。通常， 将桶数设置为预计元素个数的 75% ~ 150%。有些研究人员认为：尽管还没有确凿的证据， 但最好将桶数设置为一个素数， 以防键的集聚。标准类库使用的桶数是 2 的幂， 默认值为 16 (为表大小提供的任何值都将被自动地转换为 2 的下一个幂)。

12. 如果散列表太满， 就需要再散列 （rehashed)。 如果要对散列表再散列， 就需要创建一个桶数更多的表，并将所有元素插入到这个新表中.，然后丢弃原来的表。 

13. 装填因子（ load factor) 决定何时对散列表进行再散列。 例如， 如果装填因子为 0.75 (默认值)， 而表中超过 75% 的位置已经填人元素， 这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说， 装填因子为0.75 是比较合理的。

14. 散列表可以用于实现几个重要的数据结构。 其中最简单的是 set 类型。set 是没有重复元素的元素集合。set 的 add 方法首先在集中查找要添加的对象， 如果不存在，就将这个对象添加进去。

15. Java 集合类库提供了一个 HashSet 类，它实现了基于散列表的集。可以用 add 方法添加元素。contains 方法已经被重新定义， 用来快速地查看是否某个元素已经出现在集中。它只在某个桶中査找元素，而不必查看集合中的所有元素。

16. 散列集迭代器将依次访问所有的桶。 由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用 HashSet。

17. 在更改集中的元素时要格外小心。 如果元素的散列码发生了改变， 元素在数据结构中的位置也会发生变化。

```java
import java.util.*;

public class TestBase7{
	public static void main(String[] args) {
		Set<String> words=new HashSet<>();  //构造一个空散列表。
		long totalTime=0;

		try (Scanner in=new Scanner(System.in)){
			while (in.hasNext()){
				String word=in.next();
				long callTime=System.currentTimeMillis();
				words.add(word);
				callTime=System.currentTimeMillis()-callTime;
				totalTime+=callTime;
			}
		}
		Iterator<String> iter=words.iterator();
		for (int i=1;i<=20 && iter.hasNext(); i++) {
			if (i%5==0) {
				System.out.println();
			}
			System.out.print(iter.next()+"\t");
		}
		System.out.println("...");
		System.out.println(words.size()+" distinct words. "+totalTime+" milliseconds");
	}
}
/*读取输人的所有单词， 并且将它们添加到散列集中。然后遍历散列集中的不
同单词，最后打印出单词的数量 ,单词以随机的顺序出现。
*/
//java TestBase7 < a.txt
/*
$ java TestBase7 < a.txt
big     explosive       data    advanced
high-speed      serve   issues  sequencing      that
appeared        problem reality,        huge    those
which   development     computing(HPC)along     in      need
impact  ...
77 distinct words. 0 milliseconds
*/

```

```java
java.util.HashSet<E>
	HashSet( )
   // 构造一个空散列表。
    • HashSet( Collection<? extends E> elements )
   // 构造一个散列集， 并将集合中的所有元素添加到这个散列集中。
    • HashSet( int initialCapacity)
   // 构造一个空的具有指定容量（桶数）的散列集。
    • HashSet(int initialCapacity , float loadFactor )
	//构造一个具有指定容量和装填因子（一个 0.0 ~ 1.0 之间的数值， 确定散列表填充的百分比， 当大于这个百分比时， 散列表进行再散列）的空散列集。
java.Iang.Object l.O
    • int hashCode( )
    //返回这个对象的散列码。 散列码可以是任何整数， 包括正数或负数。equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCodeO 必须等于 y.hashCodeO。	
```

### 2.4  树集

1. TreeSet 类与散列集十分类似， 不过， 它比散列集有所改进。 树集是一个有序集合( sorted collection) .可以以任意顺序将元素插入到集合中。在对集合进行遍历时， 每个值将自动地按照排序后的顺序呈现。

   ```java
   		SortedSet<String> sorter=new TreeSet<>();
   		sorter.add("mane");
   		sorter.add("Arnold");
   		sorter.add("Alison");
   		for (String s:sorter) System.out.print(s+"\t");
   		System.out.println();
   	//Alison	Arnold	mane	
   ```

2. 正如 TreeSet 类名所示， 排序是用树结构完成的（当前实现使用的是红黑树（red-black tree )。每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

3. 将一个元素添加到树中要比添加到散列表中慢，但是， 与检查数组或链表中的重复元素相比还是快很多。

4.  要使用树集， 必须能够比较元素。 这些元素必须实现 Comparable 接口，或者构造集时必须提供一个 Comparator 

5. 是否总是应该用树集取代散列集。毕竟， 添加一个元素所花费的时间看上去并不很长，而且元素是自动排序的。到底应该怎样做将取决于所要收
   集的数据。

   - 如果不需要对数据进行排序， 就没有必要付出排序的开销。
   - 更重要的是， 对于某些数据来说， 对其排序要比散列函数更加困难。
   -  散列函数只是将对象适当地打乱存放， 而比较却要精确地判别每个对象。

6. 树的排序必须是全序。 也就是说， 任意两个元素必须是可比的， 并且只有在两个元素相等时结果才为 0。 

7.  从 JavaSE 6 起， TreeSet 类实现了 NavigableSet 接口。 这个接口增加了几个便于定位元素以及反向遍历的方法。

```java
import java.util.*;

class Item implements Comparable<Item>{
	private String description;
	private int partNumber;

	public Item(String d,int p){
		description=d;
		partNumber=p;
	}

	public String getDescription(){
		return description;
	}
	public String toString(){
		return "[description="+description+", partNumber="+partNumber+"]";
	}
	public boolean equals(Object otherObject){
		if (this==otherObject) return true;
		if (otherObject==null) return false;
		if (getClass()!=otherObject.getClass()) return false;
		Item other=(Item) otherObject;
		return Objects.equals(description,other.description) && partNumber==other.partNumber;
	}
	public int hashCode(){
		return Objects.hash(description,partNumber);
	}
	public int compareTo(Item other){
		int diff=Integer.compare(partNumber,other.partNumber);
		return diff!=0 ? diff : description.compareTo(other.description);
	}
}

public class TestBase7{
	public static void main(String[] args) {
		SortedSet<Item> sorter=new TreeSet<>();  //构造一个空树集。
		sorter.add(new Item("mane",10));
		sorter.add(new Item("Arnold",66));
		sorter.add(new Item("Alison",1));
		System.out.println(sorter);

		NavigableSet<Item> sortByDescription = new TreeSet<>(Comparator.comparing(Item::getDescription));
		//返回用于对元素进行排序的比较器。 如果元素用 Comparable 接口的 compareTo方法进行比较则返回 null。
		sortByDescription.addAll(sorter);
		System.out.println(sortByDescription);

	}
}
/*
------Output------
[[description=Alison, partNumber=1], [description=mane, partNumber=10], [description=Arnold, partNumber=66]]
[[description=Alison, partNumber=1], [description=Arnold, partNumber=66], [description=mane, partNumber=10]]
*/

```

### 2.5  队列与双端队列

1. 有两个端头的队列， 即双端队列， 可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。在 Java SE 6 中引人了 Deque 接口， 并由 ArrayDeque 和LinkedList 类实现。这两个类都提供了双端队列， 而且在必要时可以增加队列的长度。

   ```java
   java.utii.Queue<E> 5.0
   	boolean add(E element )
   	boolean offer(E element )
   	//如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回 true。如果队列满了，第一个方法将拋出一个 IllegalStateException, 而第二个方法返回 false。
   	E remove( )
   	E poll ( )
   	//假如队列不空， 删除并返回这个队列头部的元素。 如果队列是空的，第一个方法抛出NoSuchElementException, 而第二个方法返回 null。
   	E element()
   	E peek( )
   	//如果队列不空，返回这个队列头部的元素， 但不删除。 如果队列空，第一个方法将拋出一个 NoSuchElementException, 而第二个方法返回 null。
   
   java.util.Deque<E> 6
   	void addFirst(E element )
   	void addLast(E element )
   	boolean offerFirst(E element )
   	boolean offerLast( E element )
   	//将给定的对象添加到双端队列的头部或尾部。如果队列满了，前面两个方法将拋出一个 IllegalStateException， 而后面两个方法返回 false。
   	E removeFirst( )
   	E removeLast( )
   	E pollFirst()
   	E pollLast()
   	//如果队列不空，删除并返回队列头部的元素。 如果队列为空，前面两个方法将拋出一个 NoSuchElementException, 而后面两个方法返回 null。
   	E getFirst()
   	E getLast()
   	E peekFirst()
   	E peekLast( )
   	//如果队列非空，返回队列头部的元素， 但不删除。 如果队列空，前面两个方法将拋出一个 NoSuchElementException, 而后面两个方法返回 null。
   
   java.util.ArrayDeque<E> 6
   	ArrayDeque( )
   	ArrayDeque( int initialCapacity)
   	//用初始容量 16 或给定的初始容量构造一个无限双端队列。
   ```

### 2.6  优先级队列

1. 优先级队列（priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。也就是说，无论何时调用 remove 方法， 总会获得当前优先级队列中最小的元素。
2. 然而， 优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。
3. 优先级队列使用了一个优雅且高效的数据结构，称为堆（heap)。堆是一个可以自我调整的二叉树，对树执行添加 （add) 和删除（remore) 操作， 可以让最小的元素移动到根，而不必花费时间对元素进行排序。
4. 与 TreeSet—样，一个优先级队列既可以保存实现了 Comparable 接口的类对象， 也可以保存在构造器中提供的 Comparator 对象。
5. 使用优先级队列的典型示例是任务调度。每一个任务有一个优先级， 任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除（由于习惯上将 1 设为“ 最高” 优先级，所以会将最小的元素删除 )。

```java
		PriorityQueue<LocalDate> pq=new PriorityQueue<>();
		//构造一个用于存放 Comparable 对象的优先级队列。
		pq.add(LocalDate.of(1993,2,1));
		pq.add(LocalDate.of(1903,12,2));
		pq.add(LocalDate.of(2193,6,23));
		pq.add(LocalDate.of(1993,4,4));

		System.out.println("迭代元素：");
		for (LocalDate d:pq) System.out.println(d);
		System.out.println("移除元素");
		while(!pq.isEmpty()){
			System.out.println(pq.remove());
		}
```

##  3  映 射

### 3.0   映射

1. 集是一个集合，它可以快速地查找现有的元素。但是，要查看一个元素， 需要有要查找元素的精确副本。这不是一种非常通用的査找方式。
2. 通常， 我们知道某些键的信息，并想要查找与之对应的元素。 映射（map) 数据结构就是为此设计的。
3.  映射用来存放键 / 值对。如果提供了键， 就能够查找到值。

### 3.1  基本映射操作

1. Java 类库为映射提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了 Map 接口。

2. 散列映射对键进行散列， 树映射用键的整体顺序对元素进行排序， 并将其组织成搜索树。 散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。

3. 应该选择散列映射还是树映射呢？ 与集一样， 散列稍微快一些， 如果不需要按照排列顺序访问键， 就最好选择散列。

4. 每当往映射中添加对象时， 必须同时提供一个键。在这里，键是一个字符串，对应的值是 Employee 对象。

   ```java
   		Map<String,Employee> staff=new HashMap<>();
   		Employee staff1=new Employee("mane",20,1994,12,11);
   		Employee staff2=new Employee("Alison",23,1993,10,5);
   		staff.put("10",staff1);
   		staff.put("1",staff2);
   		staff.put("66",new Employee("Arnold",18,2000,4,12));
   		staff.put("11",new Employee("salah",40,2017,7,2));
   		
   		staff.forEach((k,v)->{
   			System.out.print("key="+k);
   			System.out.println("\tvalue:"+v.toString());
   			});
   		System.out.println(staff.get("10"));
   		staff.remove("1");
   		staff.put("10",new Employee("OOOO",29,2021,11,26));
   
   		System.out.println(staff.get("10"));
   		staff.forEach((k,v)->{
   			System.out.print("key="+k);
   			System.out.println("\tvalue:"+v.toString());
   			});
   
   ```

5. 要想检索一个对象， 必须使用（因而，必须记住）一个键。如果在映射中没有与给定键对应的信息， get 将返回 null。null 返回值可能并不方便。有时可以有一个好的默认值， 用作为映射中不存在的键。然后使用 getOrDefault 方法。

6. 键必须是唯一的。不能对同一个键存放两个值。 如果对同一个键两次调用 put 方法， 第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。

7. remove 方法用于从映射中删除给定键对应的元素。 size 方法用于返回映射中的元素数。

8. 要迭代处理映射的键和值， 最容易的方法是使用 forEach 方法。 可以提供一个接收键和值的 lambda 表达式。映射中的每一项会依序调用这个表达式。

### 3.2  更新映射项

1. 处理映射时的一个难点就是更新映射项。正常情况下， 可以得到与一个键关联的原值，完成更新， 再放回更新后的值。

2. 不过，必须考虑一个特殊情况， 即键第一次出现。

   看一个例子， 使用一个映射统计一个单词在文件中出现的频度。看到一个单词（word) 时， 我们将计数器增 1， 如下所示：

   ​	**counts.put(word, counts.get(word)+ 1);**

   这是可以的， 不过有一种情况除外： 就是第一次看到 word 时。在这种情况下，get 会返回 null, 因此会出现一个 NullPointerException 异常。作为一个简单的补救， 可以使用 getOrDefault 方法：

   ​	**counts,put(word, counts.getOrDefault(word, 0)+ 1);**

   另一种方法是首先调用 putlfAbsent 方法。只有当键原先存在时才会放入一个值。

   ​	**counts.putlfAbsent(word, 0);**
   ​	**counts.put(word, counts.get(word)+ 1); // Now we know that get will succeed**

   不过还可以做得更好。merge 方法可以简化这个常见的操作。如果键原先不存在，下面的调用：

   ​	**counts.merge(word, 1, Integer::sum);**

   将把 word 与 1 关联，否则使用 Integer::sum 函数组合原值和 1 (也就是将原值与 1 求和)。

   

### 3.3  映射视图

1. 集合框架不认为映射本身是一个集合。（其他数据结构框架认为映射是一个键 / 值对集合， 或者是由键索引的值集合。）不过， 可以得到映射的视图（ View )—这是实现了Collection 接口或某个子接口的对象。

2. 有 3 种视图： 键集、 值集合（不是一个集） 以及键 / 值对集。键和键 / 值对可以构成一个集， 因为映射中一个键只能有一个副本。 

   **Set<K> keySet()**
   **Collection<V> values()**
   **Set<Map.Entry<K, V» entrySet()**

   会分别返回这 3 个视图。（条目集的元素是实现 Map.Entry 接口的类的对象。）

3.  keySet 不是 HashSet 或 TreeSet， 而是实现了 Set 接口的另外某个类的对象。 Set 接口扩展了 Collection 接口。因此， 可以像使用集合一样使用 keySet。

4. 可以枚举一个映射的所有键：

   ```java
   Set<String> keys = map.keySet();
   for (String key : keys){
   	do something with key
   }
   
   for (Map.Entry<String, Employee> entry : staff.entrySet())
   {
       String k = entry.getKey()；
       Employee v = entry.getValue();
       do something with k, v
   }
   
   counts.forEach((k， v) -> {
   	dosomethingwith k, v
   });
   ```

5. 如果想同时查看键和值， 可以通过枚举条目来避免查找值。原先这是访问所有映射条目的最高效的方法。如今， 只需要使用 forEach 方法

6. 如果在键集视图上调用迭代器的 remove 方法， 实际上会从映射中删除这个键和与它关联的值。不过，不能向键集视图增加元素。另外， 如果增加一个键而没有同时增加值也是没有意义的。 如果试图调用 add 方法， 它会抛出一个 UnsupportedOperationException。 条目集视图有同样的限制，尽管理论上增加一个新的键 / 值对好像是有意义的。

### 3.4  弱散列映射

1. 垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的， 它们不能被回收。 因此， 需要由程序负责从长期存活的映射表中删除那些无用的值。 或者使用 WeakHashMap 完成这件事情。当对键的唯一引用来自散列条目时， 这一数据结构将与垃圾回收器协同工作一起删除键 / 值对。
2. WeakHashMap 使用弱引用 （weak references) 保存键。WeakReference 对象将引用保存到另外一个对象中， 在这里， 就是散列键。
3. 对于这种类型的对象， 垃圾回收器用一种特有的方式进行处理。通常， 如果垃圾回收器发现某个特定的对象已经没有他人引用了， 就将其回收。然而， 如果某个对象只能由 WeakReference 引用， 垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。
4. WeakHashMap 将周期性地检查队列， 以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用， 并且已经被收集起来。于是， WeakHashMap 将删除对应的条目。

3.5  链接散列集与映射

1. LinkedHashSet 和 LinkedHashMap类用来记住插人元素项的顺序。这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并人到双向链表中.

2. 链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get 或put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要项构造这样一个的散列映射表， 请调用

   ​	**LinkedHashMap<K, V>(initialCapacity, loadFactor, true)**

3. 访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。例如， 可能希望将访问频率高的元素放在内存中， 而访问频率低的元素则从数据库中读取。

4. 当在表中找不到元素项且表又已经满时， 可以将迭代器加入到表中， 并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。

   ```java
   protected boolean removeEldestEntry(Map.Entry<K, V > eldest)
   /*
   如果想删除 eldest 元素， 并同时返回 true, 就应该覆盖这个方法。eldest 参数是预期要
   删除的条目。这个方法将在条目添加到映射中之后调用。其默认的实现将返回 false。
   即在默认情况下，旧元素没有被删除。然而， 可以重新定义这个方法， 以便有选择地
   返回 true。例如， 如果最旧的条目符合一个条件， 或者映射超过了一定大小， 则返回
   true。
   */
   ```

   

```java
		Map<K,V> cache=new LinkedHashMap<>(128,0.75F,true){
            //每当方法返回 true 时， 就添加一个新条目，从而导致删除 eldest 条目。
			protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
				return size()>100;
			}
		}();
//另外，还可以对 eldest 条目进行评估，以此决定是否应该将它删除。 例如，可以检査与这个条目一起存在的时间戳。
```

### 3.6  枚举集与映射

1. EmimSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1。

2. EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集：

   ```java
   enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY };
   EnumSet<Weekday> always = EnumSet.allOf(Weekday.class);   //返回一个包含给定枚举类型的所有值的集。
   EnumSet<Weekday> never = EnumSet.noneOf(Weekday.class);  //返回一个空集，并有足够的空间保存给定的枚举类型所有的值。
   EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);  //返回一个包含 from 〜 to 之间的所有值（包括两个边界元素）的集。
   EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);  //返回包括给定值的集。
   
   EnumMap<Weekday, Employee〉personlnCharge = new EnumMap<>(Weekday.class);  //构造一个键为给定类型的空映射。
   ```

3. 可以使用 Set 接口的常用方法来修改 EnumSet。

4. EnumMap 是一个键类型为枚举类型的映射。 它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型.

### 3.7  标识散列映射

1. 类 IdentityHashMap 有特殊的作用。 在这个类中， 键的散列值不是用 hashCode 函数计算的， 而是用 System.identityHashCode 方法计算的。这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。 而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。

2. 也就是说， 不同的键对象， 即使内容相同， 也被视为是不同的对象。 在实现对象遍历算法 （如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。

   ```java
   java.util.ldentityHashMap<K,V>
   	IdentityHashMap();
   	IdentityHashMap(int expectedMaxSize);
   	//构造一个空的标识散列映射集，其容量是大于 1.5 * expectedMaxSize 的 2 的最小次幂	(expectedMaxSize 的默认值是 21 )。
   java.lang.System
       static int identityHashCode(Object obj)
       //返回 ObjectHashCode 计算出来的相同散列码（根据对象的内存地址产生)， 即使 obj所属的类已经重新定义了 hashCode 方法也是如此。
   ```

## 4  视图与包装器

